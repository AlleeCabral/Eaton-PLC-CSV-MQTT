<?xml version="1.0" encoding="utf-8"?>
<Library Name="CommFB, 3.5.18.0 (3S - Smart Software Solutions GmbH)">
  <Node Name="SALARM" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" | A Field Device can generate alarms to its associated Host Controller to inform it e.g. about certain process events or other events to state there are &#xD;&#xA;   some limitations of the capabilities of the Field Device for diagnostic reasons. The Host application may use the |RALARM| function block to receive these alarms. &#xD;&#xA; | &#xD;&#xA; | The ID parameter identifies the slot of the Field Device the alarm is generated for. The ATYPE input shall contain the &#xD;&#xA;   alarm type. The ASPEC input shall contain the alarm specifier. The LEN input contains the length in byte of the additional &#xD;&#xA;   alarm information stored in the AINFO parameter.&#xD;&#xA; | &#xD;&#xA; | The Variable given as AINFO parameter shall be at least of LEN byte.&#xD;&#xA; | &#xD;&#xA; | If the alarm is transmitted successfully, the VALID output indicates that the alarm was received by the Host Controller.&#xD;&#xA; | If an error occurred, the ERROR output indicates an error and the STATUS output contains the error code.&#xD;&#xA;&#xD;&#xA; .. admonition:: Code-Example&#xD;&#xA;&#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;    &#xD;&#xA;        PROGRAM SendAlarm&#xD;&#xA;        VAR&#xD;&#xA;            sender : CommFB.SALARM;&#xD;&#xA;            alarmPayload : ARRAY[0..3] OF BYTE := [0, 1, 2, 3];		// encoding for Profinet: USI (UInt16), ARRAY[0..n] OF BYTE;&#xD;&#xA;            ID : DWORD := CommFB.Constants.INVALID_ID;&#xD;&#xA;        END_VAR&#xD;&#xA;        &#xD;&#xA;        ID := CommFB.SUBSLOT_ID(EN := TRUE, ID := PN_Device.DeviceID, SLOT := 2, SUBSLOT := 1);	&#xD;&#xA;        sender.ID := ID;&#xD;&#xA;        sender.ATYPE := ProfinetCommon.AlarmType.PROCESS;&#xD;&#xA;        sender.ASPEC := 0;		// 0 for process-alarm&#xD;&#xA;        sender.LEN := SIZEOF(alarmPayload);&#xD;&#xA;        sender.AINFO := ADR(alarmPayload);&#xD;&#xA;        sender();&#xD;&#xA;        &#xD;&#xA;        IF(sender.DONE OR sender.ERROR) THEN		&#xD;&#xA;            sender(REQ := FALSE);&#xD;&#xA;        END_IF&#xD;&#xA; " ObjectGUID="{f6433d9b-94db-403f-bb14-d8000354f11a}" />
  <Node Name="RCVREC_MODE" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" ObjectGUID="{3be0aa05-e2d1-4360-88af-148b3e7cee42}" />
  <Node Name="RCVREC" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" | A Field Device can receive an acyclic process data record from a Host Controller or a Supervisor (The Host may use the |WRREC| function block). &#xD;&#xA; | The application of a programmable field device is informed about this request and can receive the data using the RCVREC function block.&#xD;&#xA; | &#xD;&#xA; | This function blocks contains the methods to check, receive and acknowledge a process data record. &#xD;&#xA; | All aspects of receiving a process data record may use one function block instance, the different methods are distinguished using the MODE input.&#xD;&#xA; | IF a data record is received (with MODE=1 OR MODE=2), the NEW output indicates that the data record is stored in the variable given AT the RECORD parameter.&#xD;&#xA; | If the function block refuses to accept the data record, the CODE1 input sets the Error Code 1, and the CODE2 input sets the Error Code 2 of the negative response.&#xD;&#xA; | If an error occurred, the ENO=0 indicates an error and the STATUS output contains the error code.&#xD;&#xA; | &#xD;&#xA;&#xD;&#xA; .. note:: The application program of the Field Device shall acknowledge the received request, otherwise the Host Controller will get a timeout error or the device stack will send a negative response.    &#xD;&#xA;&#xD;&#xA; .. admonition:: Code-Example&#xD;&#xA;&#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;    &#xD;&#xA;        PROGRAM ReceiveData&#xD;&#xA;        VAR&#xD;&#xA;            recvData: CommFB.RCVREC;&#xD;&#xA;            data : ARRAY [0..64] OF BYTE;&#xD;&#xA;            &#xD;&#xA;            recvAll: CommFB.RCVREC;	&#xD;&#xA;            param1 : ARRAY [0..7] OF BYTE;&#xD;&#xA;            param2 : ARRAY [0..7] OF BYTE;&#xD;&#xA;        END_VAR&#xD;&#xA;             &#xD;&#xA;        // Variant 1: receive data for a specific slot:&#xD;&#xA;        recvData.EN := 1;&#xD;&#xA;        recvData.F_ID := CommFB.SUBSLOT_ID(EN := TRUE, PN_Device.DeviceID, 2, 1);   // get ID of Slot 2 of the specified device&#xD;&#xA;        recvData.MLEN := SIZEOF(data);&#xD;&#xA;        recvData.RECORD := ADR(data);&#xD;&#xA;        recvData (MODE := CommFB.RCVREC_MODE.RECEIVE_BY_SLOT);      // receive data and write it to RECORD&#xD;&#xA;        IF recvData.NEW THEN        &#xD;&#xA;            IF(recvData.INDEX = 10) THEN&#xD;&#xA;                // ...process and opt. check received data&#xD;&#xA;                recvData(MODE := CommFB.RCVREC_MODE.POS_RESPONSE);  // send pos. response to host&#xD;&#xA;            ELSE&#xD;&#xA;                recvData(MODE := CommFB.RCVREC_MODE.NEG_RESPONSE, CODE1 := CommFB.ErrorCode1_RW.Invalid_index);  // signal error to host &#xD;&#xA;            END_IF&#xD;&#xA;        END_IF&#xD;&#xA;        &#xD;&#xA;        // Variant 2: check for any request and then (opt.) receive it in a second step&#xD;&#xA;        // MODE := 0  = CommFB.RCVREC_MODE.CHECK&#xD;&#xA;        // MODE := 1  = CommFB.RCVREC_MODE.RECEIVE&#xD;&#xA;        // MODE := 3  = CommFB.RCVREC_MODE.POS_RESPONSE&#xD;&#xA;        // MODE := 4  = CommFB.RCVREC_MODE.NEG_RESPONSE&#xD;&#xA;        recvAll(EN := TRUE, MODE := 0);     // check for new data &#xD;&#xA;        IF(recvAll.NEW) THEN                // received data&#xD;&#xA;            IF(recvAll.SLOT = 1 AND recvAll.INDEX = 100) THEN&#xD;&#xA;                recvAll(MODE := 1, MLEN := SIZEOF(param1), RECORD := ADR(param1));      // get data&#xD;&#xA;                recvAll(MODE := 3);     // pos. response&#xD;&#xA;            ELSIF(recvAll.SLOT = 3 AND recvAll.INDEX = 200) THEN&#xD;&#xA;                recvAll(MODE := 1, MLEN := SIZEOF(param2), RECORD := ADR(param2));      // get data&#xD;&#xA;                recvAll(MODE := 3);     // pos. response    &#xD;&#xA;            ELSE&#xD;&#xA;                recvAll(MODE := 4, CODE1 := CommFB.ErrorCode1_RW.Invalid_slot_or_subslot);     // signal error to host &#xD;&#xA;            END_IF&#xD;&#xA;        END_IF&#xD;&#xA; " ObjectGUID="{f9730001-6699-48d8-bf3b-f83abd096f11}" />
  <Node Name="PRVREC_MODE" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" ObjectGUID="{807ee85f-dc85-41fb-b0c6-f824fd15e80f}" />
  <Node Name="PRVREC" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" | A Field Device can receive a request to provide a process data record to a Host Controller or Supervisor. The host may use the |RDREC| function block. &#xD;&#xA; | The application program is informed about this request and can provide the requested process data record using the PRVREC function block.&#xD;&#xA; | &#xD;&#xA; | This function blocks contains the methods to check, receive and respond a request for a process data record. &#xD;&#xA; | All aspects of providing a process data record may use one function block instance, the different methods are distinguished using the MODE input.&#xD;&#xA; | If a data record is received (with MODE=1 or MODE=2), the NEW output indicates that the data record is stored in the variable given at the RECORD parameter. &#xD;&#xA; | If the function block refuses to accept the data record, the CODE1 input sets the Error Code1, and the CODE2 input sets the Error Code 2 of the negative response.&#xD;&#xA; | If an error occurred, the ENO=0 indicates an error and the STATUS output contains the error code.// | If an error occurred, the ENO=0 indicates an error and the STATUS output contains the error code.&#xD;&#xA; | &#xD;&#xA;&#xD;&#xA; .. note:: The application program of the Field Device shall acknowledge the received request, otherwise the Host Controller will get a timeout error or the device stack will send a negative response.    &#xD;&#xA;&#xD;&#xA; .. admonition:: Code-Example&#xD;&#xA;&#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;    &#xD;&#xA;        PROGRAM ProvideData&#xD;&#xA;        VAR&#xD;&#xA;            prvData : CommFB.PRVREC;&#xD;&#xA;            data : ARRAY[0..3] OF BYTE := [0,1,2,3];		// some dummy data&#xD;&#xA;        END_VAR&#xD;&#xA;             &#xD;&#xA;        // Variant 1: receive data for a specific slot:&#xD;&#xA;        prvData.EN := 1;&#xD;&#xA;        prvData.F_ID := CommFB.SUBSLOT_ID(EN := TRUE, PN_Device.DeviceID, 2, 1);    // get ID of Slot 2 of the specified device&#xD;&#xA;        prvData(MODE := CommFB.PRVREC_MODE.RECEIVE_BY_SLOT);        // get request      &#xD;&#xA;        IF prvData.NEW THEN     // process record&#xD;&#xA;            IF(prvData.SLOT = 1 AND  prvData.INDEX = 2) THEN&#xD;&#xA;                prvData(MODE := 3, LEN:=4, RECORD := ADR(data));    // pos. response with data&#xD;&#xA;            END_IF&#xD;&#xA;        END_IF&#xD;&#xA;        &#xD;&#xA;        // Variant 2: check for request, then decide to process it (receive + pos./neg. response)&#xD;&#xA;        prvData(MODE := CommFB.PRVREC_MODE.CHECK, F_ID := PN_Device.DeviceID);  // get request      &#xD;&#xA;        IF(prvData.NEW) THEN&#xD;&#xA;            // Reject everything else. &#xD;&#xA;            // If a request from the host is not confimed by the aplication, the stack may send a neg. response after a timeout.&#xD;&#xA;            prvData(MODE := 4, CODE1 := 16#B2); &#xD;&#xA;        END_IF&#xD;&#xA; " ObjectGUID="{7907436b-7328-4b26-85f5-5f844a02411b}" />
  <Node Name="SLOT_ID" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Provides the ID of a Profibus slot to a given Profibus DP-slave handle " ObjectGUID="{fd7ca1be-c86a-44d8-8ccf-9f1c6886b72e}" />
  <Node Name="ID" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function converts the physical identification of a slot or a DP-slave to a handle which can be used with Communication Function Blocks.&#xD;&#xA;" ObjectGUID="{f3c8e2a3-9d08-45dd-8795-8b10401ff0fe}" />
  <Node Name="ADDR" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function converts a handle which addresses a slot or a DP-slave into its physical address." ObjectGUID="{1f46981c-5032-452e-985f-e8b03125b721}" />
  <Node Name="SUBSLOT_ID" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns the ID of a subslot. " ObjectGUID="{ded43a3c-92df-49ba-9781-6700cb71f9f7}" />
  <Node Name="PN_DEVICE_ID" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" ObjectGUID="{c284315c-4b28-4abe-b120-e371e7e96a6c}" />
  <Node Name="PN_ADDR" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" Comment=" | data structure for physical/native identification or subslot of a PROFINET IO Device." ObjectGUID="{c47a08c8-d2f4-4d7a-801d-785811b6a362}" />
  <Node Name="IO_SYSTEM_TYPE" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" ObjectGUID="{c92eaa45-312c-4223-92e1-5134242146ed}" />
  <Node Name="ID_TO_ADDR" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" &#xD;&#xA; The function block ID_TO_ADDR converts the handle used for the Communication Function Blocks&#xD;&#xA; to the physical identification of a slot of a PROFIBUS DP-slave or subslot of a PROFINET IO Device.&#xD;&#xA;&#xD;&#xA; .. admonition:: Code-Example: see |RALARM|&#xD;&#xA;&#xD;&#xA;    .. code-block:: codesys&#xD;&#xA; &#xD;&#xA; | &#xD;&#xA;" ObjectGUID="{d0bab1e9-1c62-4544-865d-f2323c4dc7fc}" />
  <Node Name="DP_DEVICE_ID" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" ObjectGUID="{cb67c988-d33a-451d-8d66-d5072e021a2a}" />
  <Node Name="DP_ADDR" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" Comment=" | data structure for physical/native identification of a slot of a PROFIBUS DP-slave." ObjectGUID="{2c4c59cf-f622-4b98-8cd2-3724a6e08ac4}" />
  <Node Name="CREATE_ID" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" | This function block creates a temporary ID from the physical identification of a slot of a PROFIBUS DP-slave or subslot of a PROFINET IO Device which can be used with the Communication Function Blocks.&#xD;&#xA; | In contrast to the other address conversion functions, it does not retrieve the ID from the projected devices of the application, but creates a temporary assignment of ID and the given address.&#xD;&#xA; | Use case is for example a Profinet implicit read-service. (|RDREC| without established connection |CNCT|)&#xD;&#xA; | &#xD;&#xA;&#xD;&#xA; .. note:: Implementations may choose to only support a single or a limitted number of these temporary IDs and the underlying services.&#xD;&#xA;&#xD;&#xA; .. admonition:: Code-Example: Profinet implicit read&#xD;&#xA; &#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;     &#xD;&#xA;        PROGRAM READ_Implicit&#xD;&#xA;        VAR&#xD;&#xA;            addr : CommFB.ADDR_TYPE;&#xD;&#xA;            createID : CommFB.CREATE_ID;&#xD;&#xA;          &#xD;&#xA;            execRead : BOOL;&#xD;&#xA;            rdrec : CommFB.RDREC;&#xD;&#xA;            buffer : ARRAY[0..63] OF BYTE;&#xD;&#xA;        END_VAR&#xD;&#xA;        &#xD;&#xA;        // init address:&#xD;&#xA;        // (this data might be retrieved by a bus-scan)&#xD;&#xA;        addr.SYSTEM := CommFB.IO_SYSTEM_TYPE.PROFINET_IO;&#xD;&#xA;        addr.PN.D.STATIONNAME := 'pnDevice';      // 'pnDevice' is some online device&#xD;&#xA;        addr.PN.D.INSTANCE := 1;                  // typically 0 or 1 &#xD;&#xA;        &#xD;&#xA;        createID(ADDR := addr);&#xD;&#xA;        IF(createID.ENO AND execRead) THEN&#xD;&#xA;            // Read data from profinet device &#xD;&#xA;            rdrec.ID := createID.ID;            // ENO = TRUE, so the ID is valid and can be used for RDREC   &#xD;&#xA;            rdrec.INDEX := TO_INT(16#AFF0);     // I&amp;M1-Data     &#xD;&#xA;            rdrec.MLEN := TO_INT(SIZEOF(buffer));&#xD;&#xA;            rdrec.RECORD := ADR(buffer);&#xD;&#xA;            rdrec(REQ := execRead);&#xD;&#xA;          &#xD;&#xA;            IF(rdrec.VALID OR rdrec.ERROR) THEN&#xD;&#xA;                //execution done&#xD;&#xA;                execRead := FALSE;&#xD;&#xA;                rdrec(REQ := execRead);&#xD;&#xA;            END_IF&#xD;&#xA;        END_IF&#xD;&#xA;         " ObjectGUID="{91285ac4-fcce-4b11-a91d-784db93cb52e}" />
  <Node Name="ADDR_TYPE" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" Comment=" | Uniform data structure (UNION) for physical identification of a slot of a PROFIBUS DP-slave or subslot of a PROFINET IO Device.&#xD;&#xA; | (see: |AddressConcept|, |ADDR_TO_ID|, |ID_TO_ADDR|)" ObjectGUID="{0be6145e-367d-4a84-84f0-60a68e629dce}" />
  <Node Name="ADDR_TO_ID" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" &#xD;&#xA; | The function block ADDR_TO_ID converts the physical identification of a slot of a PROFIBUS DP-slave or subslot of a PROFINET IO Device to a handle which can be used with the Communication Function Blocks.&#xD;&#xA;&#xD;&#xA; .. admonition:: Code-Example: get ID with ADDR_TO_ID&#xD;&#xA;&#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;    &#xD;&#xA;        PROGRAM PLC_PRG&#xD;&#xA;        VAR&#xD;&#xA;            ID : DWORD := CommFB.Constants.INVALID_ID;&#xD;&#xA;            convertAddr : CommFB.ADDR_TO_ID;&#xD;&#xA;            addr : CommFB.ADDR_TYPE;    &#xD;&#xA;            errorCode : UDINT;  &#xD;&#xA;        END_VAR&#xD;&#xA;        &#xD;&#xA;        addr.SYSTEM := CommFB.IO_SYSTEM_TYPE.PROFINET_IO;&#xD;&#xA;        addr.PN.MASTER := PN_Controller.MasterID;&#xD;&#xA;        addr.PN.D.STATIONNAME := 'wago1';&#xD;&#xA;        //addr.PN.D.INSTANCE := ?;      Instance Nr - not relevant for ADDR_TO_ID()&#xD;&#xA;        //addr.PN.D.DEVICE := ?;        Device-ID   - not relevant for ADDR_TO_ID()&#xD;&#xA;        //addr.PN.D.VENDOR := ?;        Vendor-ID   - not relevant for ADDR_TO_ID()&#xD;&#xA;        addr.PN.API := 0;&#xD;&#xA;        addr.PN.SLOT := 2;              &#xD;&#xA;        addr.PN.SUBSLOT := 1;&#xD;&#xA;        &#xD;&#xA;        convertAddr(EN := TRUE, ADDR := addr);&#xD;&#xA;        IF(convertAddr.ENO) THEN&#xD;&#xA;            ID := convertAddr.ID;       // --&gt; use this ID in RDREC, WRREC etc.&#xD;&#xA;        ELSE    &#xD;&#xA;            errorCode := convertAddr.STATUS;        //failed !&#xD;&#xA;        END_IF&#xD;&#xA;&#xD;&#xA; | &#xD;&#xA;" ObjectGUID="{5161bf82-7645-4eca-8762-c6c281eca346}" />
  <Node Name="WRREC" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" | **Write Data Record (WRREC)**&#xD;&#xA; | This function block executes an acyclic write of user or system record-data.&#xD;&#xA; | The ID parameter identifies the slot or subslot of the Field Device the process data record is written to. &#xD;&#xA; | The INDEX input of the WRREC function block contains an integer which identifies the data record to be written. &#xD;&#xA; | The data record shall be stored in the variable given at the RECORD parameter.&#xD;&#xA; | The LEN input contains the length of the data record to be written in byte. &#xD;&#xA; | The variable given as RECORD parameter shall be at least of LEN byte.&#xD;&#xA; | The values of the RECORD and LEN parameters shall not be changed as long as the BUSY output is true.&#xD;&#xA; | If the data record is written successfully, the DONE output indicates that the read data record is written to the Field Device.&#xD;&#xA; | If an error occurred, the ERROR output indicates an error and the STATUS output contains the error code." ObjectGUID="{217ef9f1-e885-4091-9848-6b80a26c7ecc}" />
  <Node Name="SETIO_PART" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" &#xD;&#xA;The SETIO_PART function block sets the output data for a subset of the output data associated to a slot or subslot of a Field Device.&#xD;&#xA;The output data are addressed within the slot or subslot through the OFFSET and LEN parameters. &#xD;&#xA;The SETIO_PART function block sets the output data to the Host Controller interface into the cyclically written output data of the Field Device. &#xD;&#xA;The function block is invoked by a 1 of the EN input. If the Output data are stored successfully and the Field Device is still cyclically communicating, the ENO output is set to 1.&#xD;&#xA;&#xD;&#xA;If the Output data are stored successfully and the Field Device is still cyclically communicating, the ENO output is set to 1&#xD;&#xA;&#xD;&#xA;Never use GETIO-/SETIO_PART FBs concurrently with %I/%Q-Input/Output-Mapping for the same slot/subslot !&#xD;&#xA;" ObjectGUID="{4a9c08c8-7e07-483d-9560-4b698ff1f35a}" />
  <Node Name="RDREC" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" | **Read Process Data Record (RDREC)**&#xD;&#xA; | This function block executes an acyclic read of user or system record-data.&#xD;&#xA; | The function is invoked when REQ input is equal to TRUE.&#xD;&#xA; | The ID parameter identifies the slot or subslot of the Field Device the data record is read from. &#xD;&#xA; | The INDEX input of the READ function block contains an integer which identifies the data record to be read, e.g. Profinet Diagnosis- or I&amp;M-Data.&#xD;&#xA; | The MLEN parameter specifies the count of bytes which shall be read as an maximum. &#xD;&#xA; | The variable given as RECORD parameter shall be at least of MLEN byte.&#xD;&#xA; | If the data record is read successfully, the VALID output indicates that the read data record is stored in the RECORD parameter. &#xD;&#xA; | The LEN output contains the actual length of the data that has been read in byte.&#xD;&#xA; | If an error occurred, the ERROR output indicates an error and the STATUS output contains the error code.&#xD;&#xA;&#xD;&#xA; .. admonition:: Code-Example: use RDREC to read the diagnosis of a PN-Slave&#xD;&#xA;&#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;    &#xD;&#xA;        PROGRAM PLC_PRG&#xD;&#xA;        VAR&#xD;&#xA;            rdrec : CommFB.RDREC;   &#xD;&#xA;            buffer : ARRAY[0..255] OF BYTE;&#xD;&#xA;            readError : DWORD;&#xD;&#xA;            &#xD;&#xA;            diagReader : ProfinetCommon.DiagnosisDataReader;&#xD;&#xA;            channelDiag : ProfinetCommon.ChannelDiagnosisData;&#xD;&#xA;        END_VAR&#xD;&#xA;             &#xD;&#xA;        // Read Diagosis-Data:&#xD;&#xA;        rdrec.ID := pnDevice.ID;                // &quot;pnDevice&quot; is a Profinet slave in the device tree&#xD;&#xA;        rdrec.INDEX := TO_INT(ProfinetCommon.DiagnosisRecordIndex.Device);      // = 16#F80C --&gt; get all diagnosis for this device&#xD;&#xA;        rdrec.MLEN := TO_INT(SIZEOF(buffer));&#xD;&#xA;        rdrec.RECORD := ADR(buffer);&#xD;&#xA;        rdrec();&#xD;&#xA;        &#xD;&#xA;        IF(rdrec.VALID AND rdrec.REQ) THEN&#xD;&#xA;            //here we have valid data&#xD;&#xA;            diagReader.InitData(rdrec.RECORD, TO_UINT(rdrec.LEN));&#xD;&#xA;            WHILE(diagReader.Read()) DO&#xD;&#xA;               ; // do something useful with diag-data       &#xD;&#xA;            END_WHILE   &#xD;&#xA;        ELSIF(rdrec.ERROR) THEN&#xD;&#xA;            readError := rdrec.STATUS;      // read service failed&#xD;&#xA;        END_IF&#xD;&#xA;        rdrec.REQ := rdrec.BUSY;            // only read once&#xD;&#xA; " ObjectGUID="{d9fbb3df-cbc7-4a28-b57a-e0ee2393ee08}" />
  <Node Name="RDIAG" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" | Read Diagnosis data from DP Slave.&#xD;&#xA; | This service is for Profibus only, Profinet uses a different, more advanced Diagnosis. &#xD;&#xA; &#xD;&#xA;  .. admonition:: Code-Example: Profibus DP Diagnosis&#xD;&#xA; &#xD;&#xA;     .. code-block:: codesys&#xD;&#xA;     &#xD;&#xA;         PROGRAM PLC_PRG&#xD;&#xA;         VAR&#xD;&#xA;             readDiag : CommfB.RDIAG;&#xD;&#xA;             diag : CommFB.DP_DIAG;&#xD;&#xA;             sMessage : STRING;&#xD;&#xA;         END_VAR&#xD;&#xA;         &#xD;&#xA;         readDiag.REQ := TRUE;&#xD;&#xA;         readDiag.ID := CommFB.ID(EN := TRUE, Master := CIFX_PB.MasterID, SEGMENT := 0, STATION := 3, SLOT := 0);&#xD;&#xA;         readDiag.MLEN := TO_INT(SIZEOF(diag));&#xD;&#xA;         readDiag(DINFO := diag);&#xD;&#xA;         IF(readDiag.VALID) THEN&#xD;&#xA;             IF(diag.status1.Diag.Station_Non_Existent) THEN&#xD;&#xA;                 sMessage := 'Station with Address = 3 is not available !';&#xD;&#xA;             END_IF&#xD;&#xA;         END_IF        &#xD;&#xA;" ObjectGUID="{c5b58f61-3843-42d6-973c-c6c3d2d08db5}" />
  <Node Name="RALARM_MODE" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" Comment=" Filter scope of  |RALARM|.F_ID input." ObjectGUID="{3d01c37c-0555-41fe-8394-dbb1741e5426}" />
  <Node Name="RALARM" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" | The RALARM function block is used to receive alarm information of alarms from a PROFIBUS DP or a PROFINET IO subsystem.&#xD;&#xA; &#xD;&#xA;  .. admonition:: Code-Example: receive Alarm&#xD;&#xA; &#xD;&#xA;     .. code-block:: codesys&#xD;&#xA;     &#xD;&#xA;         PROGRAM PLC_PRG&#xD;&#xA;         VAR&#xD;&#xA;             ralarm : CommFB.RALARM;&#xD;&#xA;             alarm : CommFB.AINFO_TYPE;		&#xD;&#xA;             convertID : CommFB.ID_TO_ADDR;&#xD;&#xA;             addr : CommFB.ADDR_TYPE;				&#xD;&#xA;             message : STRING;&#xD;&#xA;         END_VAR&#xD;&#xA;         &#xD;&#xA;         &#xD;&#xA;         ralarm.EN := TRUE;&#xD;&#xA;         ralarm.MODE := CommFB.RALARM_MODE.ALL_ALARMS;       // receive all alarms from all devices connected to the controller&#xD;&#xA;         ralarm.F_ID := PN_Controller.MasterID;              // Filter ID, if MODE = ALL_ALARMS use MasterID here, else the ID of a slot/subslot&#xD;&#xA;         &#xD;&#xA;         ralarm(ainfo := alarm);&#xD;&#xA;         WHILE(ralarm.NEW) DO&#xD;&#xA; &#xD;&#xA;             convertID(EN := TRUE, ID := ralarm.ID, ADDR := addr);&#xD;&#xA;             IF(convertID.ENO) THEN&#xD;&#xA;                 IF(addr.SYSTEM = CommFB.IO_SYSTEM_TYPE.PROFINET_IO) THEN&#xD;&#xA;                     message := 'Station ';&#xD;&#xA;                     message := concat(message, addr.PN.D.STATIONNAME);&#xD;&#xA;                     message := concat(message, ' (Slot = ');&#xD;&#xA;                     message := concat(message, TO_STRING(addr.PN.SLOT));    &#xD;&#xA;                     message := concat(message, ') sends an alarm !');   &#xD;&#xA;                     &#xD;&#xA;                     //Log Alarm to PLC-Logger&#xD;&#xA;                     CmpLog.LogAdd2(CmpLog.LogConstants.LOG_STD_LOGGER, 555, CmpLog.LogClass.LOG_WARNING, 0, 0, message);   &#xD;&#xA;                 END_IF      &#xD;&#xA;             END_IF             &#xD;&#xA;             &#xD;&#xA;             ralarm(ainfo := alarm);     // exec-again&#xD;&#xA;         END_WHILE&#xD;&#xA; " ObjectGUID="{30000b14-dffc-4fca-ba84-ce8151efe9e5}" />
  <Node Name="PN_AINFO" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" Comment=" Alarm information of a profinet device (see: |RALARM|).&#xD;&#xA; (see IEC 61158-6)" ObjectGUID="{58c695ac-304e-486a-9a07-0358892da7f8}" />
  <Node Name="GETIO_PART" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" &#xD;&#xA;The GETIO_PART function block gets a subset of the input data associated to a slot or subslot of a Field Device.&#xD;&#xA;The input data are addressed within the slot or subslot through OFFSET and LEN parameters. &#xD;&#xA;The GETIO_PART function block gets the input data from the Host Controller interface out of the cyclically read input data of the Field Device. The function block is invoked by a 1 of the EN input.&#xD;&#xA;&#xD;&#xA;If the input data are valid, the ENO output is set to 1, the ERROR output is set to 0, and the input data are stored in the variable given at the INPUTS parameter. &#xD;&#xA;The variable passed to the INPUTS parameter shall be of appropriate size to receive the input data. &#xD;&#xA;&#xD;&#xA;Never use GETIO-/SETIO_PART FBs concurrently with %I/%Q-Input/Output-Mapping for the same slot/subslot ! &#xD;&#xA;" ObjectGUID="{bd69db5b-9f68-4c3f-ab2e-16010fa11131}" />
  <Node Name="ErrorCode1_RW" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" Comment=" | Some encodings of ErrorCode1 of STATUS (byte 3) that are use for acyclic read-/write services.&#xD;&#xA; | Could be used for access errors in |RCVREC| or |PRVREC| function blocks, for example." ObjectGUID="{594cfd4e-5371-430c-b6b9-799df6118df0}" />
  <Node Name="ErrorCode" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" Comment="&#xD;&#xA; * The ``STATUS`` output has the data type DWORD which is interpreted as a packed array of four bytes.&#xD;&#xA; *&#xD;&#xA; * | Byte 0:	``Function_Num``&#xD;&#xA; * | Byte 1:	``Error_Decode``&#xD;&#xA; * | Byte 2:	``Error_Code_1``&#xD;&#xA; * | Byte 3:	``Error_Code_2``&#xD;&#xA; * &#xD;&#xA; * The Elements are used as specified in IEC 61158-6 (Profibus DP, Profinet IO)&#xD;&#xA; * &#xD;&#xA; * Exception: If ``Function_Num`` has a value of 16#40, no protocol element is used.&#xD;&#xA; * This is the case for example if the validation of one input parameter failed.&#xD;&#xA; * In this case ``Error_Decode`` value of 16#82..16#8F reports an error at parameter number 2 - 15.&#xD;&#xA; * &#xD;&#xA; * Other fixed error codes are defined in this enum.&#xD;&#xA; " ObjectGUID="{0ea83946-0470-4697-83c0-4b8f9811c9c0}" />
  <Node Name="DP_DIAG" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" Comment=" | Data structure containing DP Slave diagnosis data (see: |RDIAG|).&#xD;&#xA; | (see IEC 61158-6)" ObjectGUID="{6b4cdf9f-0ef9-4dbf-9870-844452a05a5b}" />
  <Node Name="DP_AINFO" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" Comment=" | Alarm information of a profibus device (see: |RALARM|).&#xD;&#xA; | (see IEC 61158-6)" ObjectGUID="{4b43e083-02e7-4f9e-bd9a-b953c4763244}" />
  <Node Name="Constants" TypeGUID="{ffbfa93a-b94d-45fc-a329-229860183b1d}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" ObjectGUID="{64bb6af4-43c3-4bd8-9df2-83ff119f5ca4}" />
  <Node Name="CNCT" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" | This function block establishes a Profinet DeviceAccess-AR or a Profibus-DPV2 connection.&#xD;&#xA; | Supervisors need this connections to access a Field Device, e.g. for writing parameters.&#xD;&#xA; | One instance of a CNCT function block provides one instance of a peer-to-peer connection to a Field Device. Only one connection to the same Field Device can be established.&#xD;&#xA; | &#xD;&#xA; | A connection is established when the REQ input is equal to TRUE. The IO Subsystem remains connected as long as the function block is called with REQ = TRUE or an error is indicated.&#xD;&#xA; | The variable given D_ADDR input shall identify the destination Field Device. The ID output identifies the established connection to this Field Device (used for the functions blocks |RDREC| and |WRREC|.&#xD;&#xA; | If the connection is established successfully, the VALID output indicates that the connection can be used.&#xD;&#xA; | &#xD;&#xA;&#xD;&#xA; .. note:: In case of inactivity, which means there are no read-/write-services transfered on the established connection, the connection may be aborted by the IO subsystem (e.g. after 20 sec.)     &#xD;&#xA;&#xD;&#xA; .. note:: The CNCT function block defines a connection to a slot or subslot of a Field Device and returns a handle via the ID output. &#xD;&#xA;    This connection establishes an Application Relationship (AR) to the Field Device. If another connection and handle is needed to the same Field Device the existing AR may be used.&#xD;&#xA; &#xD;&#xA; .. admonition:: Code-Example: establish a Supervisor connection&#xD;&#xA; &#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;     &#xD;&#xA;        PROGRAM PLC_PRG&#xD;&#xA;        VAR&#xD;&#xA;            cnct : CommFB.CNCT;&#xD;&#xA;            startConnect : BOOL;        //establish a Supervisor connection&#xD;&#xA;            rdrec : CommFB.RDREC;&#xD;&#xA;            loadData : BOOL;&#xD;&#xA;            buffer : ARRAY[0..255] OF BYTE;&#xD;&#xA;        END_VAR&#xD;&#xA;        &#xD;&#xA;        cnct.D_ADDR.SYSTEM := CommfB.IO_SYSTEM_TYPE.PROFINET_IO;&#xD;&#xA;        cnct.D_ADDR.PN.D.STATIONNAME := 'pnDevice';&#xD;&#xA;        cnct.D_ADDR.PN.D.VENDOR := 16#011D;         //get this data from GSDML or DCP_Identify / Scan&#xD;&#xA;        cnct.D_ADDR.PN.D.DEVICE := 16#02EE;&#xD;&#xA;        cnct.D_ADDR.PN.D.INSTANCE := 0;&#xD;&#xA;        &#xD;&#xA;        cnct.D_ADDR.PN.SLOT := 0;&#xD;&#xA;        cnct.D_ADDR.PN.SUBSLOT := 1;&#xD;&#xA;        &#xD;&#xA;        cnct.REQ := startConnect;&#xD;&#xA;        cnct();&#xD;&#xA;        IF(cnct.VALID) THEN&#xD;&#xA;            loadData := TRUE;&#xD;&#xA;        ELSIF(cnct.ERROR) THEN&#xD;&#xA;            //re-connect, if connection timed out&#xD;&#xA;            startConnect := (cnct.STATUS = CommFB.ErrorCode.TIMEOUT);&#xD;&#xA;        END_IF&#xD;&#xA;        &#xD;&#xA;        // Read Diagnosis-Data&#xD;&#xA;        rdrec.REQ := loadData;&#xD;&#xA;        rdrec.ID := cnct.ID;&#xD;&#xA;        rdrec.INDEX := TO_INT(ProfinetCommon.DiagnosisRecordIndex.Device);&#xD;&#xA;        rdrec.MLEN := TO_INT(SIZEOF(buffer));&#xD;&#xA;        rdrec.RECORD := ADR(buffer);&#xD;&#xA;        rdrec();&#xD;&#xA;        &#xD;&#xA;        IF(rdrec.REQ) THEN&#xD;&#xA;            IF(rdrec.VALID) THEN&#xD;&#xA;                loadData := FALSE;&#xD;&#xA;                startConnect := FALSE;  //Release connection&#xD;&#xA;            END_IF&#xD;&#xA;        END_IF&#xD;&#xA;        rdrec.REQ := rdrec.BUSY;&#xD;&#xA;         " ObjectGUID="{1a0938d0-793f-43ea-b09a-2fa860cf65f3}" />
  <Node Name="AddressConcept" TypeGUID="{ffbfa93a-b94d-45fc-a329-229860183b1d}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" Comment=" ===============&#xD;&#xA; Address Concept&#xD;&#xA; ===============&#xD;&#xA; | &#xD;&#xA; | IO Systems like PROFIBUS DP and PROFINET IO use different address concepts. &#xD;&#xA; | This results in different functions or function parameters to identify a Field Device, a slot or subslot inside a Field Device.&#xD;&#xA; | &#xD;&#xA; | In order to provide an uniform interface for the use with different types of IO communication subsystems, all Communication Function Blocks hide the address concept of the specific IO Systems. &#xD;&#xA; | The Function Blocks use an abstract ''ID'', a handle of data type DWORD, to uniquely identify a Profibus-Module or a Profinet-Submodule within an application.&#xD;&#xA; | Therefore an application program is able to use the Communication Function Blocks without knowledge of the explicit hardware configuration (e.g. the MAC address or Station-Name of a Field Device or the slot-position of a module). &#xD;&#xA; | This way an application or library can be developed without dependencies to hardware configuration data such as a specific IO-Driver or an addressing method.&#xD;&#xA; | &#xD;&#xA; | &#xD;&#xA;&#xD;&#xA; Generating a CommFB-ID&#xD;&#xA; ======================&#xD;&#xA; | There are different methods, generic and more specific ones, to generate an ID for identifying a Profibus/Profinet device:&#xD;&#xA;&#xD;&#xA; .. note:: The actual value of ID should never be manipulated or created,&#xD;&#xA;    only use the IDs created from theses sources described here.&#xD;&#xA;    The value of ID can differ depending on the project structure or the driver version ! &#xD;&#xA;&#xD;&#xA; | &#xD;&#xA;&#xD;&#xA; Profibus DP&#xD;&#xA; ===========&#xD;&#xA; | The input parameter ID of the Communication Function Blocks addresses one slot of a DP-slave or a DP-slave (Slot 0). &#xD;&#xA; | This handle may be generated by using one of the following functions:&#xD;&#xA;&#xD;&#xA; * |ID|: Conversion of a physical address of a DP-slave to the handle&#xD;&#xA;&#xD;&#xA; * |ADDR|: Conversion of a handle to the physical address of a DP-slave&#xD;&#xA;&#xD;&#xA; * |SLOT_ID|: Addressing a slot of a DP-slave&#xD;&#xA;&#xD;&#xA; |&#xD;&#xA;&#xD;&#xA; Profinet IO&#xD;&#xA; =============&#xD;&#xA; | The input parameter ID of the Communication Function Blocks addresses a Profinet-Submodule.&#xD;&#xA; | A Profinet Module is just a container for at least one submodule. IO-Data and Parameters are always assigned to a submodule.&#xD;&#xA; | The shortest way to get the ID of a submodule is to call the GetID()-method of the Profinet-Slave function block which is generated for each Profinet-Slave device:&#xD;&#xA;&#xD;&#xA; .. admonition:: Code-Example: ID with GetID() - method&#xD;&#xA;&#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;    &#xD;&#xA;        PROGRAM PLC_PRG&#xD;&#xA;        VAR&#xD;&#xA;            ID : DWORD := CommFB.Constants.INVALID_ID;&#xD;&#xA;        END_VAR&#xD;&#xA;    &#xD;&#xA;        ID := PNSlave.GetID(API := 0, SLOT := 1, SUBSLOT = 1);	// get ID of 1. module&#xD;&#xA;&#xD;&#xA; |&#xD;&#xA; &#xD;&#xA; Device Diagnosis&#xD;&#xA; ==================&#xD;&#xA; | A generic way for obtaining an CommFB-ID is by calling the method IDevice.GetDeviceInfo().&#xD;&#xA; | For an underlying Profinet/Profibus slave or module, the generic DEVICE_INFO structure, which is returned by this method, contains the unique CommFB-ID:&#xD;&#xA;&#xD;&#xA; .. admonition:: Code-Example: ID with generic Device Diagnosis&#xD;&#xA;&#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;    &#xD;&#xA;        FUNCTION ListStationnames : DINT&#xD;&#xA;        VAR_IN_OUT&#xD;&#xA;            controller : DED.IDevice;&#xD;&#xA;        END_VAR&#xD;&#xA;        &#xD;&#xA;        VAR&#xD;&#xA;            i : DINT;&#xD;&#xA;            childDevice : DED.IDevice;&#xD;&#xA;            deviceInfo : DED.DEVICE_INFO;&#xD;&#xA;            &#xD;&#xA;            convertID : CommFB.ID_TO_ADDR;&#xD;&#xA;            pnAddress : CommFB.ADDR_TYPE;&#xD;&#xA;            stationName : STRING;&#xD;&#xA;        END_VAR&#xD;&#xA;        &#xD;&#xA;        FOR i := 0 TO TO_DINT(controller.ChildNodeCount - 1) DO&#xD;&#xA;            childDevice := DED.INode_TO_IDevice(controller.GetChild(TO_UDINT(i)));&#xD;&#xA;            IF(childDevice &lt;&gt; 0 AND_THEN childDevice.GetDeviceInfo(deviceInfo) = DED.ERROR.NO_ERROR) THEN&#xD;&#xA;                convertID(EN := TRUE, ID := deviceInfo.idSystem, ADDR := pnAddress);&#xD;&#xA;                IF(convertID.ENO) THEN&#xD;&#xA;                    IF(pnAddress.SYSTEM = CommFB.IO_SYSTEM_TYPE.PROFINET_IO) THEN&#xD;&#xA;                        //we have a valid Profinet Address:&#xD;&#xA;                        stationName := pnAddress.PN.D.STATIONNAME;&#xD;&#xA;                    END_IF&#xD;&#xA;                END_IF&#xD;&#xA;            END_IF&#xD;&#xA;        END_FOR&#xD;&#xA;&#xD;&#xA; | &#xD;&#xA;&#xD;&#xA; Address Conversion&#xD;&#xA; ====================&#xD;&#xA; | For some use cases it may be necessary to use native PROFIBUS DP and PROFINET IO addressing.&#xD;&#xA; | These function blocks can be used for obtaining an ID to a native, protocol specific address and vice versa (see examples in the function block's description)&#xD;&#xA; | The handle may be generated by local means of the PLC or its configuration system or may be generated by using one of the following functions:&#xD;&#xA;&#xD;&#xA; * |ADDR_TO_ID|: Conversion of a address of a PROFINET IO Device to the handle&#xD;&#xA;&#xD;&#xA; * |ID_TO_ADDR|: Conversion of a handle to the address of a PROFINET IO Device&#xD;&#xA;&#xD;&#xA; |&#xD;&#xA;" ObjectGUID="{71003b0f-a879-4760-b7e7-43a60ae694ca}" />
  <Node Name="AINFO_TYPE" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" Comment=" | This union either contain Profibus or Profinet alarm information, depending on the used IO subsytem type (see: |RALARM|)." ObjectGUID="{406c9b69-07cd-4f68-98f6-648eff1b3a53}" />
  <Node Name="Bibliotheksverwalter" TypeGUID="{adb5cb65-8e1d-4a00-b70a-375ea27582f3}" EmbeddedTypeGUIDs="" ObjectGUID="{ee40785b-2a85-4eb3-b4a1-b8940b60184b}" />
</Library>