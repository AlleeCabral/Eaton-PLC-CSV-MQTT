<?xml version="1.0" encoding="utf-8"?>
<Library Name="CAA Can Low Level Extern, 3.5.21.0 (CAA Technical Workgroup)">
  <Node Name="_IsErrorStateIndicatorBitEnabled" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |IsErrorStateIndicatorBitEnabled|&#xD;&#xA;&#xD;&#xA; :return:  error state indicator bit" ObjectGUID="{d460f90f-db87-4734-afd2-5e4c0cb477d8}" />
  <Node Name="_IsBitrateSwitchingBitEnabled" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |IsBitrateSwitchingBitEnabled|&#xD;&#xA;&#xD;&#xA; :return:  bit rate switching bit" ObjectGUID="{7bee069c-ac74-4039-9171-221dd4d4023b}" />
  <Node Name="_FdDriverOpenP" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |FdDriverOpenP|" ObjectGUID="{f2537e89-d69c-4890-949f-d81c65874a2a}" />
  <Node Name="_FdDriverOpenH" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |FdDriverOpenH|" ObjectGUID="{de44d6ab-5bf0-49e5-aa1e-038e517b40e6}" />
  <Node Name="_FdDriverGetSize" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |FdDriverGetSize|" ObjectGUID="{6e8beae7-3346-4bf2-ad0e-7a94000d70c4}" />
  <Node Name="_CreateFdMessage" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |CreateFdMessage|" ObjectGUID="{39ac4497-1e58-4b12-a388-f11f00ca54e2}" />
  <Node Name="IsErrorStateIndicatorBitEnabled" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns the error state indicator bit of a CAN FD message handle.&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    See |Read|.&#xD;&#xA;&#xD;&#xA; :return:  error state indicator bit" ObjectGUID="{b2f6f3b7-f247-405f-bfbf-0d739658cd4a}" />
  <Node Name="IsBitrateSwitchingBitEnabled" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns the bitrate switching bit of a CAN FD message handle.&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    See |Read|.&#xD;&#xA;&#xD;&#xA; :return:  bit rate switching bit" ObjectGUID="{8236f33c-e6ef-48a0-b0ad-3dac3d69215c}" />
  <Node Name="_LostMessages" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |LostMessages|&#xD;&#xA;&#xD;&#xA; :return:  Counter, which is incremented with every lost message of ``hReceiverId``" ObjectGUID="{a5e3739b-009d-49e9-ba33-831103363fe2}" />
  <Node Name="_IsTransmitMessage" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |IsTransmitMessage|&#xD;&#xA;&#xD;&#xA; :return:  ``TRUE`` if messages is a Transmit CAN message." ObjectGUID="{e309da6a-d987-4a0f-a179-c99ef7d79bc7}" />
  <Node Name="_IsRTRMessage" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |IsRTRMessage|&#xD;&#xA;&#xD;&#xA; :return: ``TRUE`` if messages is a RTR CAN message." ObjectGUID="{d64cbb36-b435-486b-bbbd-3f9e14d6b0d6}" />
  <Node Name="_IsFdMessage" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |IsFdMessage|&#xD;&#xA;&#xD;&#xA; :return:  ``TRUE`` if message is a CAN FD message." ObjectGUID="{89b36a9f-9f92-4235-b1e3-6e3637a25885}" />
  <Node Name="_Is29BitIdMessage" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |Is29BitIdMessage|&#xD;&#xA;&#xD;&#xA; :return: ``TRUE`` if messages is a 29 bit CAN message." ObjectGUID="{216a852e-65d6-49ce-b5a1-fd7745eb8eab}" />
  <Node Name="_GetTimeStamp" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetTimeStamp|&#xD;&#xA;&#xD;&#xA; :return: Time Stamp of ``hMessage``." ObjectGUID="{fec6d3be-d16b-491a-8cd1-54c9fa4606eb}" />
  <Node Name="_GetNetId" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetNetId|&#xD;&#xA;&#xD;&#xA; :return: NetID of ``hMessage``." ObjectGUID="{d0cd6f41-c927-4340-afd2-1b7713b5bc17}" />
  <Node Name="_GetMsgCount" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetMsgCount|&#xD;&#xA;&#xD;&#xA; :return: number of messages in receive queue of ``hReceiverId``." ObjectGUID="{8411d588-c851-4a80-911e-414b93f1c95d}" />
  <Node Name="_GetMessageLength" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetMessageLength|&#xD;&#xA;&#xD;&#xA; :return: number of valid data bytes in message" ObjectGUID="{81f5e0bc-7554-41ae-abc4-4d1bd03abb99}" />
  <Node Name="_GetMessageId" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetMessageId|&#xD;&#xA;&#xD;&#xA; :return: COBID of a message" ObjectGUID="{12925632-552d-4f14-8811-8572c87eccb1}" />
  <Node Name="_GetMessageDataPointer2" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetMessageDataPointer2|&#xD;&#xA;&#xD;&#xA; :return: Pointer to message data" ObjectGUID="{cd6a36f4-4526-4016-aedc-a1807d9e0785}" />
  <Node Name="_GetMessageDataPointer" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetMessageDataPointer|&#xD;&#xA;&#xD;&#xA; :return: Pointer to message data" ObjectGUID="{95013cd4-4d5c-4a4e-845e-34a46c7325a9}" />
  <Node Name="_SetCiAState" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |SetCiAState|&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{c9f3691c-3eb2-42be-8983-b615dbfee840}" />
  <Node Name="_GetCiAState" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetCiAState|&#xD;&#xA;&#xD;&#xA; :return: current CiA state (see |IndicatorConstants|)" ObjectGUID="{079263c0-fe4c-4873-a5d0-cd18661d6cdf}" />
  <Node Name="_EnableSyncService" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |EnableSyncService|&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{f8c506f4-d60d-4376-9e17-b68c95f0e25a}" />
  <Node Name="_DisableSyncService" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |DisableSyncService|&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{b51b47f9-5569-4ba6-bcfb-684481965c1d}" />
  <Node Name="_ResetBusAlarm" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |ResetBusAlarm|&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{672880b9-7c22-40af-9bec-c8ea420e888a}" />
  <Node Name="_IsSendingActive" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |IsSendingActive|&#xD;&#xA;&#xD;&#xA; :return: ``FALSE`` if the sending queue is empty and the CAN hardware is actually not transmitting a message." ObjectGUID="{7391ff6f-4ba0-4af3-871e-91d8a0a7bde4}" />
  <Node Name="_GetTransmitQueueLength" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetTransmitQueueLength|&#xD;&#xA;&#xD;&#xA; :return: number of messages in transmit queue." ObjectGUID="{41ad3af4-df91-4182-b1d4-91ff2dd7f16b}" />
  <Node Name="_GetTransmitPoolSize" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetTransmitPoolSize|&#xD;&#xA;&#xD;&#xA; :return: number of free transmit messages in transmit pool." ObjectGUID="{31e53610-9754-49e1-a9f6-9d4a341e5527}" />
  <Node Name="_GetTransmitErrorCounter" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetTransmitErrorCounter|&#xD;&#xA;&#xD;&#xA; :return: number of transmit errors" ObjectGUID="{4a9c2385-0caa-4152-aeed-e22f8d806b83}" />
  <Node Name="_GetTransmitCounter" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetTransmitCounter|&#xD;&#xA;&#xD;&#xA; :return: number of sent messages" ObjectGUID="{fafb5b48-7016-4f23-a6a5-5bd75344851d}" />
  <Node Name="_GetReceiveQueueLength" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetReceiveQueueLength|&#xD;&#xA;&#xD;&#xA; :return: number of messages in receive queue" ObjectGUID="{fd55c987-e397-429b-af7e-b68838e215a7}" />
  <Node Name="_GetReceivePoolSize" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetReceivePoolSize|&#xD;&#xA;&#xD;&#xA; :return: number of free receive messages in global receive pool" ObjectGUID="{7330a94d-5128-44ff-8718-b9e985e06b51}" />
  <Node Name="_GetReceiveErrorCounter" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetReceiveErrorCounter|&#xD;&#xA;&#xD;&#xA; :return: number of receive errors" ObjectGUID="{e0ba6443-d85c-4b95-9df0-f05effabca16}" />
  <Node Name="_GetReceiveCounter" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetReceiveCounter|&#xD;&#xA;&#xD;&#xA; :return: number of received messages" ObjectGUID="{a0b4aff4-a3a1-40e1-8a78-cf13d7af48ad}" />
  <Node Name="_GetLostCounter" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetLostCounter|&#xD;&#xA;&#xD;&#xA; :return: number of lost messages" ObjectGUID="{7e8c5a94-f287-437d-9735-b9a1c524d59b}" />
  <Node Name="_GetDiagnosis2" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Function returns all relevant diagnostic information for a specific CAN or CAN FD driver.&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{73ad9b5e-b936-4b86-a759-b90323577be4}" />
  <Node Name="_GetDiagnosis" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetDiagnosis|&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{42453788-3b50-457a-b70d-2049693aa3a3}" />
  <Node Name="_GetBusload" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetBusload|&#xD;&#xA;&#xD;&#xA; :return: bus load (0..100) in percent" ObjectGUID="{136c2295-23e1-476b-bd25-d1c4842193ad}" />
  <Node Name="_GetBusState" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetBusState|&#xD;&#xA;&#xD;&#xA; :return: current bus state" ObjectGUID="{6467e137-89e1-4be9-90b6-7390b8f53525}" />
  <Node Name="_GetBusAlarm" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetBusAlarm|&#xD;&#xA;&#xD;&#xA; :return: ``TRUE`` if a bus alarm is pending." ObjectGUID="{afa1420a-7a91-45ce-ba2d-359626448593}" />
  <Node Name="_GetBaudrate" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |GetBaudrate|&#xD;&#xA;&#xD;&#xA; :return: baudrate in kBit/s" ObjectGUID="{d5e3100b-e10d-449e-9db8-9abc1d6c3f5e}" />
  <Node Name="_Write" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |Write|&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{adeb8941-cf67-4f4c-9676-cb587cc1c1d3}" />
  <Node Name="_UnregisterIdArea" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |UnregisterIdArea|&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{f006eee6-01db-43fc-860f-ebde993c5456}" />
  <Node Name="_RegisterIdArea" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |RegisterIdArea|&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{e9b5cff8-8b11-4fd9-861b-504139b03b66}" />
  <Node Name="_ReadArrayReceiver" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Reads messages from an Array Receiver created by |_CreateArrayReceiver|&#xD;&#xA;&#xD;&#xA; :return:  handle of received CAN message or ``CAA.gc_hINVALID`` if receiver is empty." ObjectGUID="{92656dc6-5793-4c66-bda1-cd1040d48da0}" />
  <Node Name="_Read" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |Read|&#xD;&#xA;&#xD;&#xA; :return:  handle of received CAN message or ``CAA.gc_hINVALID`` if receiver is empty." ObjectGUID="{16548164-2796-4681-aa13-bcfd4fcbff5d}" />
  <Node Name="_FreeMessage" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |FreeMessage|&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{c89e1d00-0472-4d13-a96e-f2546eea8598}" />
  <Node Name="_DriverOpenP" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |DriverOpenP|" ObjectGUID="{fd95f402-333f-4498-9b67-bf276e9ca3b2}" />
  <Node Name="_DriverOpenH" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |DriverOpenH|&#xD;&#xA;&#xD;&#xA; :return:  handle of CAN interface or ``CAA.gc_hINVALID`` if failed." ObjectGUID="{0845dbd0-0885-4034-b326-c73e364ebdff}" />
  <Node Name="_DriverGetSize" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" See |DriverGetSize|.&#xD;&#xA;&#xD;&#xA; :return:  Required memory size for |_DriverOpenP|" ObjectGUID="{2644b94d-db3e-403c-8591-92cb9bead902}" />
  <Node Name="_DriverClose" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |DriverClose|&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{defc9f32-c022-4168-b4d7-75a9c3ae9e4b}" />
  <Node Name="_DeleteReceiver" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |DeleteReceiver|&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{26ae537b-08b7-4724-91fd-fece1d1fc9c1}" />
  <Node Name="_CreateSingleIdReceiver" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |CreateSingleIdReceiver|&#xD;&#xA;&#xD;&#xA; :return: new receiver handle or ``CAA.gc_hINVALID`` in case of failure" ObjectGUID="{f03aa989-f67c-454d-845b-c1a95eeff045}" />
  <Node Name="_CreateMessage" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |CreateMessage|&#xD;&#xA;&#xD;&#xA; :return: new message handle" ObjectGUID="{520dfd0e-c732-4bba-b1ec-60ee3b267b30}" />
  <Node Name="_CreateMaskReceiver" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |CreateMaskReceiver|&#xD;&#xA;&#xD;&#xA; :return: new receiver handle or ``CAA.gc_hINVALID`` in case of failure" ObjectGUID="{59e6c158-5fad-49b7-ad70-d389baa42e2b}" />
  <Node Name="_CreateIdAreaReceiver" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |CreateIdAreaReceiver|" ObjectGUID="{8270b641-f133-4ccb-ad3b-43b92ef54524}" />
  <Node Name="_CreateArrayReceiver" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Creates an Array Receiver.&#xD;&#xA;&#xD;&#xA; :return: new receiver handle or ``CAA.gc_hINVALID`` in case of failure" ObjectGUID="{e0f55d67-9213-4c2c-9881-9a4b4ad90ad3}" />
  <Node Name="_CloneMessage" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Unmanaged implementation of |CloneMessage|&#xD;&#xA;&#xD;&#xA; :return: cloned message handle" ObjectGUID="{69756922-4aeb-4cfc-810c-e509116a4fcb}" />
  <Node Name="FdDriverOpenP" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" See |FdDriverOpenH| for details. In contrast to |FdDriverOpenH| no dynamic memory will be allocated.&#xD;&#xA; Memory specified by ``pMemory`` and ``szMemSize`` will be used.&#xD;&#xA; Use |FdDriverGetSize| to calculate the required memory size. &#xD;&#xA; Please note that required memory size can change with new runtime version.&#xD;&#xA;&#xD;&#xA; .. note::&#xD;&#xA;&#xD;&#xA;    pMemory should be aligned to a 4 byte address on 32 bit systems and an 8 byte address on 64 bit systems.&#xD;&#xA;    To ensure this alignment, you can declare the memory with ARRAY [0..n] of __XWORD.&#xD;&#xA;	  Please keep in mind that the required memory size is different for 32 and 64-bit systems.&#xD;&#xA;  &#xD;&#xA; :return:  handle of CAN FD interface or ``CAA.gc_hINVALID`` if failed." ObjectGUID="{e990ee7f-7a86-4013-bb45-62971bbb28a7}" />
  <Node Name="FdDriverOpenH" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Opens a CAN FD interface and allocates memory from heap.&#xD;&#xA; Please note that not all hardware supports every baud rate combination. If a baud rate is not supported or &#xD;&#xA; if the interface cannot be opened due to different reasons, the function returns ``CAA.gc_hINVALID``.&#xD;&#xA; The function can be called several times on the same interface, so that multiple parts of a program can work on it.&#xD;&#xA; You can set ``uiNominalBaudrate`` and ``uiDataBaudrate`` to 0 if the interface is already opened or if the default baudrate from configuration file should be used.&#xD;&#xA; See following section in configuration file:&#xD;&#xA;&#xD;&#xA; | [CmpCAACanL2]&#xD;&#xA; | PersistentBaudrate=1&#xD;&#xA; | Net.0.DefaultBaudrate=500&#xD;&#xA; | Net.0.DefaultDataBaudrate=4000&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    See |Write|.&#xD;&#xA;&#xD;&#xA; :return:  handle of CAN FD interface or ``CAA.gc_hINVALID`` if failed." ObjectGUID="{49c073aa-7456-433f-8bd9-65f1080234d3}" />
  <Node Name="FdDriverGetSize" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Calculates the required memory size for |FdDriverOpenP|. &#xD;&#xA;&#xD;&#xA; :return:  Required memory size in bytes for |FdDriverOpenP|" ObjectGUID="{ebe87dc4-905a-4258-bb6a-d950402fabda}" />
  <Node Name="CreateFdMessage" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function allocates a new Fd message from the data pool of a FD driver and makes it available via its&#xD;&#xA; handle ``hFdMessage``. In addition, the function sets the CAN ID, data length and bitrate switching flag of the message.&#xD;&#xA; Such a message must either be sent with |Write| or released with |FreeMessage|. It can also be duplicated by use of |CloneMessage|.&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    See |Write|.&#xD;&#xA;  &#xD;&#xA; :return: new message handle or ``CAA.gc_hINVALID`` if no resources left" ObjectGUID="{596a8ec6-d79f-4ddf-bfe9-014a394db356}" />
  <Node Name="LostMessages" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns counter, which is incremented with every lost message of ``hReceiverId``&#xD;&#xA;&#xD;&#xA; :return:  Counter, which is incremented with every lost message of ``hReceiverId``" ObjectGUID="{4ad4c5b1-5884-4169-8cc6-a13f8d658ee0}" />
  <Node Name="IsTransmitMessage" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function specifies whether a message was previously sent with |Write|.&#xD;&#xA;&#xD;&#xA; :return:  ``TRUE`` if messages is a Transmit CAN message." ObjectGUID="{a5d94eda-b0d4-4957-ac9a-2bfb7fa1e063}" />
  <Node Name="IsRTRMessage" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function specifies whether a message is an RTR message. &#xD;&#xA;&#xD;&#xA; :return: ``TRUE`` if messages is a RTR CAN message." ObjectGUID="{91d5f489-6c0f-482f-b3f3-6529d985d309}" />
  <Node Name="IsFdMessage" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function returns whether a message is a CAN FD message.&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    See |Read|.&#xD;&#xA;&#xD;&#xA; :return:  ``TRUE`` if message is a CAN FD message." ObjectGUID="{c2cc84a3-88aa-4c73-a66e-e8270bdbd028}" />
  <Node Name="Is29BitIdMessage" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function determines if a specified message has an identifier with 11 bits or 29 bits.&#xD;&#xA;&#xD;&#xA; :return: ``TRUE`` if messages is a 29 bit CAN message." ObjectGUID="{6e0279b0-26aa-48e1-a912-70f0b2a352b9}" />
  <Node Name="GetTimeStamp" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns the time stamp of a given message (if supported by CAN driver, else 0).&#xD;&#xA;&#xD;&#xA; :return: Time Stamp of ``hMessage``." ObjectGUID="{784f3c75-af3d-44a3-ba19-8612a2c4e238}" />
  <Node Name="GetNetId" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns the NetID of a given message.&#xD;&#xA;&#xD;&#xA; :return: NetID of ``hMessage``." ObjectGUID="{6021d7cf-9e20-4db5-8577-e1e6ae6f64f9}" />
  <Node Name="GetMsgCount" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns the number of messages in the receive queue of a given receiver.&#xD;&#xA;&#xD;&#xA; :return: number of messages in receive queue of ``hReceiverId``." ObjectGUID="{2d68541c-a8c2-4edb-af87-af1132ff7563}" />
  <Node Name="GetMessageLength" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns number of valid bytes in message.&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    See |GetMessageDataPointer|.&#xD;&#xA;&#xD;&#xA; :return: number of valid data bytes in message" ObjectGUID="{6fdea264-bd2a-4ebe-9bf8-407331cb68a7}" />
  <Node Name="GetMessageId" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns the COBID of a message&#xD;&#xA;&#xD;&#xA; :return: COBID of a message" ObjectGUID="{8440b99d-c0ae-45cf-9f0f-4103e5699aa5}" />
  <Node Name="GetMessageDataPointer2" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns pointer to the first data byte of a message. Number of valid bytes can be retrieved by |GetMessageLength|.&#xD;&#xA;&#xD;&#xA; .. note::&#xD;&#xA;&#xD;&#xA;    The data is organised in the “Network Byte Order“ of the CANbus. &#xD;&#xA;    The alignment of data types in the RTS memory may differ from the alignment in the data messages.&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    See |Read| or |Write|.&#xD;&#xA;&#xD;&#xA; :return: Pointer to message data" ObjectGUID="{0cf78353-ba36-484b-92c7-cbb4b9605a65}" />
  <Node Name="GetMessageDataPointer" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns pointer to the eight data bytes of a message. Number of valid bytes can be retrieved by |GetMessageLength|.&#xD;&#xA;&#xD;&#xA; .. note::&#xD;&#xA;&#xD;&#xA;    The data is organised in the “Network Byte Order“ of the CANbus. &#xD;&#xA;    The alignment of data types in the RTS memory may differ from the alignment in the data messages.&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;&#xD;&#xA;       VAR&#xD;&#xA;         hMsg : CAA.HANDLE;&#xD;&#xA;         pData : POINTER TO CL2I.DATA;&#xD;&#xA;         usiMsgLen : USINT;&#xD;&#xA;         byFirstByte : BYTE;&#xD;&#xA;         bySecondByte : BYTE;&#xD;&#xA;         eError : CL2.ERROR;&#xD;&#xA;       END_VAR&#xD;&#xA;&#xD;&#xA;		 IF hMsg &lt;&gt; CAA.gc_hINVALID THEN&#xD;&#xA;           //Get message data pointer&#xD;&#xA;           pData := CL2.GetMessageDataPointer(hMessage := hMsg, peError := ADR(eError));&#xD;&#xA;           usiMsgLen := CL2.GetMessageLength(hMessage := hMsg, peError := ADR(eError)); //get number of valid bytes&#xD;&#xA;           IF pData &lt;&gt; CAA.gc_pNULL THEN&#xD;&#xA;               byFirstByte := pData^[0];&#xD;&#xA;               bySecondByte := pData^[1];&#xD;&#xA;           END_IF&#xD;&#xA;       END_IF&#xD;&#xA;&#xD;&#xA; :return: Pointer to message data" ObjectGUID="{c02d577e-6de8-4cd2-85e0-5c91da4a5544}" />
  <Node Name="SetCiAState" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Sets the current CiA LED state according to CiA 303-3. Interpretation of ``usiState`` see |IndicatorConstants|.&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{f1a57dc0-306f-4c12-a17c-41fbd410ad7f}" />
  <Node Name="GetCiAState" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns the current CiA LED state according to CiA 303-3. Interpretation of returned ``USINT`` see |IndicatorConstants|.&#xD;&#xA;&#xD;&#xA; :return: current CiA state (see |IndicatorConstants|)" ObjectGUID="{cd7c8539-7622-40e0-bad6-aa3dbda417c9}" />
  <Node Name="EnableSyncService" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Enables the SYNC service for a given network. The CANopen Stack uses this function for better SYNC accuracy.&#xD;&#xA; If service is enabled SYNC message will be sent by the CAN driver implementation.&#xD;&#xA;&#xD;&#xA; .. note::&#xD;&#xA;&#xD;&#xA;   Sync Service is not supported by all CAN drivers.&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{8c95ce91-aa6c-4e51-9af0-ab71eb156c12}" />
  <Node Name="DisableSyncService" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Disables the SYNC service for a given driver.&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{37337951-3752-4cfb-8db2-97126424a00d}" />
  <Node Name="ResetBusAlarm" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" In case of a Bus Alarm (|GetBusAlarm| returns ``TRUE``) this function can be called to reset the CAN Hardware.&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{ffb91414-1b49-41aa-8b08-444d9154dee2}" />
  <Node Name="IsSendingActive" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function specifies whether the CAN hardware is busy sending CAN messages or whether further messages are stored and waiting to be sent.&#xD;&#xA;&#xD;&#xA; :return: ``FALSE`` if the sending queue is empty and the CAN hardware is actually not transmitting a message." ObjectGUID="{90fcdf9f-2635-43cd-9777-c407c82f3668}" />
  <Node Name="GetTransmitQueueLength" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns number of messages in transmit queue waiting for being processed by CAN Minidriver.&#xD;&#xA; Diagnostic Information can be also read by |GetDiagnosis|.&#xD;&#xA;&#xD;&#xA; :return: number of messages in transmit queue." ObjectGUID="{d258499c-61a9-40af-82ed-76331cfa9ea3}" />
  <Node Name="GetTransmitPoolSize" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns the number of free transmit messages in the transmit message pool of the current driver. &#xD;&#xA; Should be greater 0. Otherwise no more messages can be sent.&#xD;&#xA; Diagnostic Information can be also read by |GetDiagnosis|.&#xD;&#xA;&#xD;&#xA; :return: number of free transmit messages in transmit pool." ObjectGUID="{29216b9b-0277-4b2b-8c5a-76726b4c430c}" />
  <Node Name="GetTransmitErrorCounter" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns a counter which is incremented with each transmit error.&#xD;&#xA; Diagnostic Information can be also read by |GetDiagnosis|.&#xD;&#xA;&#xD;&#xA; :return: number of transmit errors" ObjectGUID="{4bee2534-98b8-4067-88d6-5712423674fe}" />
  <Node Name="GetTransmitCounter" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns a counter which is incremented with each sent message.&#xD;&#xA; Diagnostic Information can be also read by |GetDiagnosis|.&#xD;&#xA;&#xD;&#xA; :return: number of sent messages" ObjectGUID="{aee1e864-5302-4a80-842c-6fb9bcc27e91}" />
  <Node Name="GetReceiveQueueLength" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns the number of messages in receive queue waiting for being processed by application or stack.&#xD;&#xA; Diagnostic Information can be also read by |GetDiagnosis|.&#xD;&#xA;&#xD;&#xA; :return: number of messages in receive queue" ObjectGUID="{21cc3725-fc00-4885-a035-f87fa78d8123}" />
  <Node Name="GetReceivePoolSize" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns the number of free receive messages in global receive pool. Should be greater 0. Otherwise no more messages can be received.&#xD;&#xA; Diagnostic Information can be also read by |GetDiagnosis|.&#xD;&#xA;&#xD;&#xA; :return: number of free receive messages in global receive pool" ObjectGUID="{e202164c-11fe-451d-a8ad-8974e47d2320}" />
  <Node Name="GetReceiveErrorCounter" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns a counter which is incremented with each receive error.&#xD;&#xA; Diagnostic Information can be also read by |GetDiagnosis|.&#xD;&#xA;&#xD;&#xA; :return: number of receive errors" ObjectGUID="{74824337-8286-425f-a3b0-1eecc8f8c4c7}" />
  <Node Name="GetReceiveCounter" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns a counter which is incremented with each received message.&#xD;&#xA; Diagnostic Information can be also read by |GetDiagnosis|.&#xD;&#xA;&#xD;&#xA; :return: number of received messages" ObjectGUID="{233686a1-433a-4457-b6c8-1eeed8cd3eee}" />
  <Node Name="GetLostCounter" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Returns a counter which is incremented with each lost message.&#xD;&#xA; Diagnostic Information can be also read by |GetDiagnosis|.&#xD;&#xA;&#xD;&#xA; :return: number of lost messages" ObjectGUID="{d9630e3d-9df7-4906-9f85-e2a8e9267be6}" />
  <Node Name="GetDiagnosis2" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Function returns all relevant diagnostic information for a specific CAN or CAN FD driver.&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{17356ce0-4d60-42c1-b55b-84c18af1005d}" />
  <Node Name="GetDiagnosis" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Function returns all relevant diagnostic information for a specific driver.&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{acd568d0-9ef5-4576-bd54-a2be6710abb2}" />
  <Node Name="GetBusload" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function is not implemented by all drivers. It returns the current busload in percent.&#xD;&#xA; Diagnostic Information can be also read by |GetDiagnosis|.&#xD;&#xA;&#xD;&#xA; :return: bus load (0..100) in percent" ObjectGUID="{7c7ccb35-c25d-49c8-b021-aa0cfa10ffe4}" />
  <Node Name="GetBusState" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function return the current state of the bus.&#xD;&#xA; Diagnostic Information can be also read by |GetDiagnosis|.&#xD;&#xA;&#xD;&#xA; :return: current bus state" ObjectGUID="{f86ee406-b058-47f4-b74b-ea753df26e6e}" />
  <Node Name="GetBusAlarm" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function returns if the CAN chip is in Bus Alarm state. In this state sending and receiving messages is not possible.&#xD;&#xA; A Bus Alarm can be reset by |ResetBusAlarm| which leads to a re-initialization of the CAN chip.&#xD;&#xA; Diagnostic Information can be also read by |GetDiagnosis|.&#xD;&#xA;&#xD;&#xA; :return: ``TRUE`` if a bus alarm is pending." ObjectGUID="{dad34db9-c512-41a1-bda2-4aa33d52aad9}" />
  <Node Name="GetBaudrate" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function returns the current baudrate of the bus.&#xD;&#xA; Information can be also read by |GetDiagnosis|.&#xD;&#xA;&#xD;&#xA; :return: baudrate in kBit/s" ObjectGUID="{ada59c23-c4b3-44dc-8ab0-61aef67fec92}" />
  <Node Name="Write" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function writes a CAN or CAN FD message (see also |CreateMessage| and |CreateFdMessage|) via a CAN or CAN FD interface specified by ``hDriver``.&#xD;&#xA; If ``Write`` returns |ERROR.NO_ERROR| the message was successfully handed over to the lower layers and will be automatically released&#xD;&#xA; after successful sending (Note: Do not call |FreeMessage| on such handles anymore!).&#xD;&#xA; If the message cannot be sent the function returns the error code |ERROR.SENDING_ERROR| and sending process must be repeated later.&#xD;&#xA; Otherwise the message handle has to be manually freed by application (see |FreeMessage|).&#xD;&#xA; &#xD;&#xA; Messages can be sent with different priorities. Messages with the same priority are sent in chronological order. &#xD;&#xA; Messages with higher priority (means lower ``usiPriority``) are always sent prior to those with lower priority.&#xD;&#xA; Priority 0 has a special meaning: messages with priority 0 are sent as soon as possible prior to all other messages waiting for transport. &#xD;&#xA; If a priority level not valid for the driver is used the message is not sent and function returns an error code.&#xD;&#xA; If the applied coblD is registered for reception and transmit messages are activated for receiving &#xD;&#xA; (see ``TransmitMask`` and ``TransmitValue`` of Receiver), a message which was sent successfully can be received&#xD;&#xA; via |Read| with a current timestamp (if timestamps are supported by driver). The function |IsTransmitMessage| returns ``TRUE`` on such messages.&#xD;&#xA;&#xD;&#xA; .. note::&#xD;&#xA;&#xD;&#xA;    Following rules are important when using ``CL2.Write``:&#xD;&#xA;&#xD;&#xA;      1. | In case of ``CL2.Write`` returns |ERROR.NO_ERROR| the message was successfully handed over to the CL2 layer. &#xD;&#xA;         | Do not use the message handle anymore! It will be automatically released.&#xD;&#xA;         | To avoid using such handles it is helpful setting ``hMessage`` to ``CAA.gc_hINVALID`` directly after calling ``CL2.Write``&#xD;&#xA;&#xD;&#xA;      2. | In case of ``CL2.Write`` returns any error, the message still belongs to the application.&#xD;&#xA;         | Do not forget to release the message!&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    In this example a classic CAN driver will be opened and a classic CAN message (CANopen NMT reset message) will be sent.&#xD;&#xA;&#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;&#xD;&#xA;       VAR&#xD;&#xA;           xInitialized : BOOL;&#xD;&#xA;           hDriver : CAA.HANDLE;&#xD;&#xA;           hMsg : CAA.HANDLE;&#xD;&#xA;           pData : POINTER TO BYTE;&#xD;&#xA;           eError : CL2.ERROR;&#xD;&#xA;       END_VAR&#xD;&#xA;       &#xD;&#xA;       IF NOT xInitialized THEN&#xD;&#xA;           hDriver := CL2.DriverOpenH(usiNetId := 0,&#xD;&#xA;                                   uiBaudrate := 1000,&#xD;&#xA;                                   xSupport29Bits := FALSE,&#xD;&#xA;                                   ctMessages := 100,&#xD;&#xA;                                   peError := ADR(eError)&#xD;&#xA;           );&#xD;&#xA;       &#xD;&#xA;           IF hDriver &lt;&gt; CAA.gc_hINVALID THEN&#xD;&#xA;               xInitialized := TRUE;&#xD;&#xA;           ELSE&#xD;&#xA;               RETURN;&#xD;&#xA;           END_IF&#xD;&#xA;       END_IF&#xD;&#xA;       &#xD;&#xA;       //Create message&#xD;&#xA;       hMsg := CL2.CreateMessage(hDriver := hDriver,&#xD;&#xA;                               cobID := 16#0,&#xD;&#xA;                               usiLength := 2,&#xD;&#xA;                               xRTR := FALSE,&#xD;&#xA;                               x29BitID := FALSE,&#xD;&#xA;                               peError := ADR(eError)&#xD;&#xA;       );&#xD;&#xA;       &#xD;&#xA;       IF hMsg &lt;&gt; CAA.gc_hINVALID THEN&#xD;&#xA;           //Get message data pointer&#xD;&#xA;           pData := CL2.GetMessageDataPointer2(hMessage := hMsg, peError := ADR(eError));&#xD;&#xA;           IF pData &lt;&gt; CAA.gc_pNULL THEN&#xD;&#xA;               //initialize message data&#xD;&#xA;               pData[0] := 16#81;&#xD;&#xA;               pData[1] := 16#0;&#xD;&#xA;           END_IF&#xD;&#xA;       &#xD;&#xA;           //send message&#xD;&#xA;           eError := CL2.Write(hDriver := hDriver,&#xD;&#xA;                             hMessage := hMsg,&#xD;&#xA;                             usiPriority := 1, //highest priority&#xD;&#xA;                             xEnableSyncWindow := FALSE&#xD;&#xA;           );&#xD;&#xA;       &#xD;&#xA;           IF eError &lt;&gt; CL2.ERROR.NO_ERROR THEN&#xD;&#xA;               //sending was not successful ==&gt; release the message&#xD;&#xA;               CL2.FreeMessage(hMsg);&#xD;&#xA;           END_IF&#xD;&#xA;       END_IF&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    In this example a CAN FD driver will be opened. The program sends a CAN FD and a classic CAN messge over the CAN FD interface.&#xD;&#xA;&#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;&#xD;&#xA;       VAR&#xD;&#xA;           xInitialized : BOOL;&#xD;&#xA;           hDriver : CAA.HANDLE;&#xD;&#xA;           hMsg : CAA.HANDLE;&#xD;&#xA;           pData : POINTER TO BYTE;&#xD;&#xA;           eError : CL2.ERROR;&#xD;&#xA;           usiIndex : USINT;&#xD;&#xA;       END_VAR&#xD;&#xA;       &#xD;&#xA;       IF NOT xInitialized THEN&#xD;&#xA;           hDriver := CL2.FdDriverOpenH(usiNetId := 0,&#xD;&#xA;                                       uiNominalBaudrate := 500,&#xD;&#xA;                                       uiDataBaudrate := 4000,&#xD;&#xA;                                       xSupport29Bits := FALSE,&#xD;&#xA;                                       ctMessages := 100,&#xD;&#xA;                                       peError := ADR(eError)&#xD;&#xA;           );&#xD;&#xA;       &#xD;&#xA;           IF hDriver &lt;&gt; CAA.gc_hINVALID THEN&#xD;&#xA;               xInitialized := TRUE;&#xD;&#xA;           ELSE&#xD;&#xA;               RETURN;&#xD;&#xA;           END_IF&#xD;&#xA;       END_IF&#xD;&#xA;       &#xD;&#xA;       //Example 1: Send a CAN FD message&#xD;&#xA;       hMsg := CL2.CreateFdMessage(hFdDriver := hDriver,&#xD;&#xA;                               cobID := 16#123,&#xD;&#xA;                               usiLength := 64,&#xD;&#xA;                               x29BitID := FALSE,&#xD;&#xA;                               xBitrateSwitching := TRUE,&#xD;&#xA;                               peError := ADR(eError)&#xD;&#xA;       );&#xD;&#xA;       &#xD;&#xA;       IF hMsg &lt;&gt; CAA.gc_hINVALID THEN&#xD;&#xA;           //Get message data pointer&#xD;&#xA;           pData := CL2.GetMessageDataPointer2(hMessage := hMsg, peError := ADR(eError));&#xD;&#xA;           IF pData &lt;&gt; CAA.gc_pNULL THEN&#xD;&#xA;               //initialize message data&#xD;&#xA;               FOR usiIndex := 0 TO 63 DO&#xD;&#xA;                   pData[usiIndex] := usiIndex;&#xD;&#xA;               END_FOR&#xD;&#xA;           END_IF&#xD;&#xA;       &#xD;&#xA;           //send message&#xD;&#xA;           eError := CL2.Write(hDriver := hDriver,&#xD;&#xA;                             hMessage := hMsg,&#xD;&#xA;                             usiPriority := 1, //highest priority&#xD;&#xA;                             xEnableSyncWindow := FALSE&#xD;&#xA;           );&#xD;&#xA;       &#xD;&#xA;           IF eError &lt;&gt; CL2.ERROR.NO_ERROR THEN&#xD;&#xA;             //sending was not successful ==&gt; release the message&#xD;&#xA;             CL2.FreeMessage(hMsg);&#xD;&#xA;           END_IF&#xD;&#xA;       END_IF&#xD;&#xA;       &#xD;&#xA;       //Example 2: Send a classic CAN message&#xD;&#xA;       hMsg := CL2.CreateMessage(hDriver := hDriver,&#xD;&#xA;                               cobID := 16#0,&#xD;&#xA;                               usiLength := 2,&#xD;&#xA;                               xRTR := FALSE,&#xD;&#xA;                               x29BitID := FALSE,&#xD;&#xA;                               peError := ADR(eError)&#xD;&#xA;       );&#xD;&#xA;       &#xD;&#xA;       IF hMsg &lt;&gt; CAA.gc_hINVALID THEN&#xD;&#xA;           //Get message data pointer&#xD;&#xA;           pData := CL2.GetMessageDataPointer2(hMessage := hMsg, peError := ADR(eError));&#xD;&#xA;           IF pData &lt;&gt; CAA.gc_pNULL THEN&#xD;&#xA;               //initialize message data&#xD;&#xA;               pData[0] := 16#81;&#xD;&#xA;               pData[1] := 16#0;&#xD;&#xA;           END_IF&#xD;&#xA;       &#xD;&#xA;           //send message&#xD;&#xA;           eError := CL2.Write(hDriver := hDriver,&#xD;&#xA;                             hMessage := hMsg,&#xD;&#xA;                             usiPriority := 1, //highest priority&#xD;&#xA;                             xEnableSyncWindow := FALSE&#xD;&#xA;           );&#xD;&#xA;       &#xD;&#xA;           IF eError &lt;&gt; CL2.ERROR.NO_ERROR THEN&#xD;&#xA;               //sending was not successful ==&gt; release the message&#xD;&#xA;               CL2.FreeMessage(hMsg);&#xD;&#xA;           END_IF&#xD;&#xA;       END_IF&#xD;&#xA;&#xD;&#xA; :return: error" ObjectGUID="{5f39d50c-7028-4e0f-9c73-8ea1464e3e74}" />
  <Node Name="UnregisterIdArea" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function removes a CAN identifier area previously added by |RegisterIdArea|.&#xD;&#xA;&#xD;&#xA; :return: error" ObjectGUID="{9ff2f685-db30-4d48-8007-cb059961ce1b}" />
  <Node Name="RegisterIdArea" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function registers a CAN identifier area to an IdAreaReceiver created by |CreateIdAreaReceiver|.&#xD;&#xA; If the parameter ``cobIdStart`` equals ``cobIdEnd`` only one identifier is registered. &#xD;&#xA; The values of the masks activate the evaluation of the value parameters. &#xD;&#xA; If the mask value is ``FALSE`` the value parameter is ignored.&#xD;&#xA;&#xD;&#xA; Receivers can be also used for Tx loopback. If ``xTransmitMask`` is set to ``FALSE`` or ``xTransmitMask`` and ``xTransmitValue`` are set to ``TRUE`` &#xD;&#xA; CAN messages which are sent via |Write| will be received (applies to all transmit messages on the CAN interface). &#xD;&#xA; Use function |IsTransmitMessage| to distinguish between receive and transmit messages.&#xD;&#xA;&#xD;&#xA; .. note::&#xD;&#xA;&#xD;&#xA;    Current implementation of this receiver type does not support 29 bit identifiers. Set ``x29BitIdValue`` always to ``FALSE`` and &#xD;&#xA;    ``x29BitIdMask`` to ``TRUE``. Otherwise an error will be returned.&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    See |CreateIdAreaReceiver|.&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| if area was registered successfully, else appropriate error code" ObjectGUID="{60ebffd8-1db8-470f-8448-27b83ef40a92}" />
  <Node Name="Read" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Receives CAN or CAN FD messages from a receiver.&#xD;&#xA;&#xD;&#xA; .. note::&#xD;&#xA;&#xD;&#xA;    To avoid losing receive messages an application has to read all messages of all receivers each cycle.&#xD;&#xA;    All messages should be processed and released by |FreeMessage| afterwards.&#xD;&#xA;&#xD;&#xA; .. note::&#xD;&#xA;&#xD;&#xA;    | Normally a receiver returns ``CAA.gc_hINVALID`` if all messages are read by application.&#xD;&#xA;    | But receivers with ``xAlwaysNewest`` = ``TRUE`` return always the newest message even if it was already received.&#xD;&#xA;    | The application has to free the message each time it is returned by CL2.Read!!!&#xD;&#xA;    | In case of an always newest receiver the data ``pctMsgLeft`` points to should be interpreted as follows:&#xD;&#xA;    | **0**: old message; **1**: new message; **2**: message overflow&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;    &#xD;&#xA;       VAR&#xD;&#xA;           xInitialized : BOOL;&#xD;&#xA;           hDriver : CAA.HANDLE;&#xD;&#xA;           hReceiver : CAA.HANDLE;&#xD;&#xA;           hMsg : CAA.HANDLE;&#xD;&#xA;           ctMsgLeft : CAA.COUNT;&#xD;&#xA;           pbyData : POINTER TO BYTE;&#xD;&#xA;           usiDataLength : USINT;&#xD;&#xA;           xFd : BOOL;&#xD;&#xA;           xBRS : BOOL;&#xD;&#xA;           xESI : BOOL;&#xD;&#xA;           eError : CL2.ERROR;&#xD;&#xA;       END_VAR&#xD;&#xA;       &#xD;&#xA;       IF NOT xInitialized THEN&#xD;&#xA;           hDriver := CL2.DriverOpenH(usiNetId := 0,&#xD;&#xA;                                   uiBaudrate := 1000,&#xD;&#xA;                                   xSupport29Bits := FALSE,&#xD;&#xA;                                   ctMessages := 100,&#xD;&#xA;                                   peError := ADR(eError)&#xD;&#xA;           );&#xD;&#xA;&#xD;&#xA;           // Alternative:&#xD;&#xA;           //hDriver := CL2.FdDriverOpenH(usiNetId := 0,&#xD;&#xA;           //                            uiNominalBaudrate := 500,&#xD;&#xA;           //                            uiDataBaudrate := 4000,&#xD;&#xA;           //                            xSupport29Bits := FALSE,&#xD;&#xA;           //                            ctMessages := 100,&#xD;&#xA;           //                            peError := ADR(eError)&#xD;&#xA;           //);&#xD;&#xA;       &#xD;&#xA;           //Create a MaskReceiver which receives all messages with CAN ID 16#80.&#xD;&#xA;           hReceiver := CL2.CreateMaskReceiver(hDriver := hDriver,&#xD;&#xA;                                               cobIdValue := 16#80, //cobID value&#xD;&#xA;                                               cobIdMask := 16#FFFFFFFF, //cobID mask ==&gt; all bits of value are relevant&#xD;&#xA;                                               xRTRValue := FALSE, //no RTR messages&#xD;&#xA;                                               xRTRMask := TRUE, //activate RTR filter ==&gt; xRTRValue will be checked&#xD;&#xA;                                               x29BitIdValue := FALSE, //no 29 bit CAN messages&#xD;&#xA;                                               x29BitIdMask := TRUE, //activate 29 bit filter ==&gt; x29BitIdValue will be checked&#xD;&#xA;                                               xTransmitValue := FALSE, //only receive messages, no transmit message loopback&#xD;&#xA;                                               xTransmitMask := TRUE, //activate transmit mask filter ==&gt; xTransmitValue will be checked&#xD;&#xA;                                               xAlwaysNewest := FALSE, //FALSE := receiver with queue; TRUE: only newest message&#xD;&#xA;                                               eEvent := CB.EVENT.NO_EVENT, //no receive event&#xD;&#xA;                                               xEnableSyncWindow := FALSE, //not implemented&#xD;&#xA;                                               peError := ADR(eError) //optional pointer to error&#xD;&#xA;           );&#xD;&#xA;       &#xD;&#xA;           IF hReceiver &lt;&gt; CAA.gc_hINVALID THEN&#xD;&#xA;               xInitialized := TRUE;&#xD;&#xA;           ELSE&#xD;&#xA;               RETURN;&#xD;&#xA;           END_IF&#xD;&#xA;       END_IF&#xD;&#xA;       &#xD;&#xA;       REPEAT&#xD;&#xA;           //receive a message from hReceiver&#xD;&#xA;           hMsg := CL2.Read(hReceiverId := hReceiver, pctMsgLeft := ADR(ctMsgLeft), peError := ADR(eError));&#xD;&#xA;           IF hMsg &lt;&gt; CAA.gc_hINVALID THEN&#xD;&#xA;               //TODO: Process message, for example:&#xD;&#xA;               pbyData := CL2.GetMessageDataPointer2(hMessage := hMsg, peError := ADR(eError));&#xD;&#xA;               usiDataLength := CL2.GetMessageLength(hMessage := hMsg, peError := ADR(eError));&#xD;&#xA;               //following code applies if hDriver is a CAN FD interface opened by FdDriverOpenH or FdDriverOpenP&#xD;&#xA;               xFd := Cl2.IsFdMessage(hMessage := hMsg, peError := ADR(eError));&#xD;&#xA;               IF xFd THEN&#xD;&#xA;                   //it's a CAN FD message&#xD;&#xA;                   xBRS := CL2.IsBitrateSwitchingBitEnabled(hFdMessage := hMsg, peError := ADR(eError));&#xD;&#xA;                   xESI := CL2.IsErrorStateIndicatorBitEnabled(hFdMessage := hMsg, peError := ADR(eError));&#xD;&#xA;               END_IF&#xD;&#xA;               //Processing finished&#xD;&#xA;       &#xD;&#xA;               CL2.FreeMessage(hMsg); //release message to avoid handle leak&#xD;&#xA;               hMsg := CAA.gc_hINVALID;&#xD;&#xA;           END_IF&#xD;&#xA;       UNTIL ctMsgLeft = 0&#xD;&#xA;       END_REPEAT&#xD;&#xA;&#xD;&#xA; :return:  handle of received CAN or CAN FD message or ``CAA.gc_hINVALID`` if receiver is empty." ObjectGUID="{c1a4fad8-9185-403b-800f-b5da3f10d3c8}" />
  <Node Name="FreeMessage" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function releases a message that has been created with |CreateMessage|, read with |Read| or duplicated with |CloneMessage|.&#xD;&#xA;&#xD;&#xA; .. note::&#xD;&#xA;&#xD;&#xA;    | Do not free a message after it has been passed to the CL2 layer. &#xD;&#xA;    | Example: Creating a message, then passing the message handle to CL2 by calling |Write| and releasing it afterwards may result in unexpected behaviour.&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{aaffc5d1-9eaf-405b-8235-242017174060}" />
  <Node Name="DriverOpenP" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" See |DriverOpenH| for details. In contrast to |DriverOpenH| no dynamic memory will be allocated. &#xD;&#xA; Memory specified by ``pMemory`` and ``szMemSize`` is used.&#xD;&#xA; Use |DriverGetSize| to calculate the required memory size. &#xD;&#xA; Please note that required memory size can change with new runtime version.&#xD;&#xA;&#xD;&#xA; .. note::&#xD;&#xA;&#xD;&#xA;    pMemory should be aligned to a 4 byte address on 32 bit systems and an 8 byte address on 64 bit systems.&#xD;&#xA;    To ensure this alignment, you can declare the memory with ARRAY [0..n] of __XWORD.&#xD;&#xA;    Please keep in mind that the required memory size is different for 32 and 64-bit systems.&#xD;&#xA;  &#xD;&#xA; :return:  handle of CAN interface or ``CAA.gc_hINVALID`` if failed." ObjectGUID="{35108394-c366-4164-9b8c-a18ea02e89c6}" />
  <Node Name="DriverOpenH" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Opens a CAN interface and allocates memory from heap.&#xD;&#xA; Not every hardware supports each baud rate. If a baud rate is not supported or &#xD;&#xA; if the interface cannot be opened due to different reasons, the function returns ``CAA.gc_hINVALID``.&#xD;&#xA; The function can be called several times on the same interface, &#xD;&#xA; so that multiple parts of a program can work on it. &#xD;&#xA; You can set ``uiBaudrate`` to 0 if the interface is already opened or if the default baudrate from configuration file should be used.&#xD;&#xA; See following section in configuration file:&#xD;&#xA;&#xD;&#xA; | [CmpCAACanL2]&#xD;&#xA; | PersistentBaudrate=1&#xD;&#xA; | Net.0.DefaultBaudrate=1000&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    See |Write|.&#xD;&#xA;&#xD;&#xA; :return:  handle of CAN interface or ``CAA.gc_hINVALID`` if failed." ObjectGUID="{d1a0601d-2e34-4ac9-897e-fc4a6bb555ba}" />
  <Node Name="DriverGetSize" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Calculates the needed memory size for |DriverOpenP|. &#xD;&#xA;&#xD;&#xA; :return:  Required memory size for |DriverOpenP|" ObjectGUID="{72ba8477-b308-48f2-ab0b-9addb1ddb2e2}" />
  <Node Name="DriverClose" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" Closes a CAN interface and frees all resources.&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{d13e964e-3132-4a42-8895-2cb25f3ccdee}" />
  <Node Name="DeleteReceiver" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function releases all ressources of a specific receiver.&#xD;&#xA;&#xD;&#xA; .. note::&#xD;&#xA;&#xD;&#xA;    When calling |DriverClose| all receivers connected to this driver are released automatically.&#xD;&#xA;    Do not call ``DeleteReceiver`` afterwards!&#xD;&#xA;&#xD;&#xA; :return: |ERROR.NO_ERROR| or appropriate error code" ObjectGUID="{abb002e1-4789-4f90-b044-87894297c3c7}" />
  <Node Name="CreateSingleIdReceiver" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function creates a receiver for one specific CAN identifier. For receiving a message use the returned receiver handle for |Read| function call.&#xD;&#xA; There are two kind of receivers:&#xD;&#xA;&#xD;&#xA; * **Always Newest Receivers (xAlwaysNewest := TRUE):** Receiver holds only the last received message.&#xD;&#xA; * **Receiver with Queue (xAlwaysNewest := FALSE):** Receiver holds messages in chronological order.&#xD;&#xA;&#xD;&#xA; Receivers can be also used for Tx loopback. If ``xTransmit`` is set to ``TRUE`` CAN messages which are sent via |Write| will be received &#xD;&#xA; (applies to all transmit messages on the CAN interface). &#xD;&#xA; Use function |IsTransmitMessage| to distinguish between receive and transmit messages.&#xD;&#xA;&#xD;&#xA; .. note::&#xD;&#xA;&#xD;&#xA;    To avoid losing receive messages an application has to read all messages of a receiver each cycle.&#xD;&#xA;    All messages should be processed and released by |FreeMessage| afterwards.&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    In this example a single ID receiver is created. It receives all RTR messages on CAN ID 16#100.&#xD;&#xA;&#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;&#xD;&#xA;       VAR&#xD;&#xA;         hDriver : CAA.HANDLE;&#xD;&#xA;         hReceiver : CAA.HANDLE;&#xD;&#xA;         hMsg : CAA.HANDLE;&#xD;&#xA;         pData : POINTER TO CL2I.DATA;&#xD;&#xA;         eError : CL2.ERROR;&#xD;&#xA;         ctMsgLeft : CAA.COUNT;&#xD;&#xA;       END_VAR&#xD;&#xA;&#xD;&#xA;       hReceiver := CL2.CreateSingleIdReceiver(hDriver := hDriver,&#xD;&#xA;                                               cobId := 16#100,&#xD;&#xA;                                               xRTR := TRUE,&#xD;&#xA;                                               x29BitId := FALSE,&#xD;&#xA;                                               xTransmit := FALSE,&#xD;&#xA;                                               xAlwaysNewest := FALSE,&#xD;&#xA;                                               eEvent := CB.EVENT.NO_EVENT, //no receive event&#xD;&#xA;                                               xEnableSyncWindow := FALSE, //not implemented&#xD;&#xA;                                               peError := ADR(eError) //optional pointer to error&#xD;&#xA;       );&#xD;&#xA;       &#xD;&#xA;       REPEAT&#xD;&#xA;           //receive a message from hReceiver&#xD;&#xA;           hMsg := CL2.Read(hReceiverId := hReceiver, pctMsgLeft := ADR(ctMsgLeft), peError := ADR(eError));&#xD;&#xA;           IF hMsg &lt;&gt; CAA.gc_hINVALID THEN&#xD;&#xA;               //TODO: Process message (CL2.GetMessageDataPointer, CL2.GetMessageId, ...)&#xD;&#xA;               CL2.FreeMessage(hMsg); //release message&#xD;&#xA;               hMsg := CAA.gc_hINVALID; //to avoid using an already released message&#xD;&#xA;           END_IF&#xD;&#xA;       UNTIL ctMsgLeft = 0&#xD;&#xA;       END_REPEAT&#xD;&#xA;&#xD;&#xA; Optionally, an event can be registered which is triggered upon reception of a corresponding message. &#xD;&#xA; A callback function can be registerd via ``CB.RegisterCallback`` (CAA Callback library). &#xD;&#xA; Use event class ``CB.EVENT_CLASS.FIELDBUS``, event source ``CB.EVENT_SOURCE.CB_DRIVER`` and any unassigned event number (see ``CB.EVENT``). &#xD;&#xA; Use the same event number for ``eEvent`` input.&#xD;&#xA; Input variable ``dwParam`` of the registered callback function contains the CAN ID of the received message.&#xD;&#xA;&#xD;&#xA; .. note::&#xD;&#xA;&#xD;&#xA;    Event mechanism is not supported on all systems. Futhermore it is not possible to register an event for extended identifiers (29bit).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    In this example a single ID receiver with event callback is created.&#xD;&#xA;&#xD;&#xA;    **Step 1:** Define a callback function with following interface (function name can be changed!).&#xD;&#xA;&#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;&#xD;&#xA;       FUNCTION CallbackReceiveCANMessage : DWORD&#xD;&#xA;       VAR_INPUT &#xD;&#xA;         dwSpec  : DWORD;  (* CB.Event and CB.EventClass *)&#xD;&#xA;         dwSource : DWORD; (* CB.EventSource *)&#xD;&#xA;         dwParam : DWORD;  (* CAN ID *)&#xD;&#xA;       END_VAR&#xD;&#xA;&#xD;&#xA;    **Step 2:** Activate ``Enable system call`` in build settings of ``CallbackReceiveCANMessage``.&#xD;&#xA;&#xD;&#xA;    **Step 3:** Register callback and create receiver.&#xD;&#xA;&#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;&#xD;&#xA;       VAR&#xD;&#xA;         hDriver : CAA.HANDLE;&#xD;&#xA;         hReceiver : CAA.HANDLE;&#xD;&#xA;         eError : CL2.ERROR;&#xD;&#xA;         callback : CB.CB_CALLBACK;&#xD;&#xA;         hEvent : CAA.HANDLE;&#xD;&#xA;         eCBError : CB.ERROR;&#xD;&#xA;       END_VAR&#xD;&#xA;&#xD;&#xA;       callBack.eClass := CB.EVENT_CLASS.FIELDBUS;&#xD;&#xA;       callback.eSource := CB.EVENT_SOURCE.DRIVER;&#xD;&#xA;       callback.eEvent := 10000; //any unassigned event number&#xD;&#xA;       callback.pPOUFunc := ADR(CallbackReceiveCANMessage);&#xD;&#xA;&#xD;&#xA;       hEvent := CB.RegisterCallback(callback, ADR(eCBError));&#xD;&#xA;&#xD;&#xA;       hReceiver := CL2.CreateSingleIdReceiver(hDriver := hDriver,&#xD;&#xA;                                               cobId := 16#100,&#xD;&#xA;                                               xRTR := FALSE,&#xD;&#xA;                                               x29BitId := FALSE,&#xD;&#xA;                                               xTransmit := FALSE,&#xD;&#xA;                                               xAlwaysNewest := FALSE,&#xD;&#xA;                                               eEvent := 10000, //use the previously registered event number&#xD;&#xA;                                               xEnableSyncWindow := FALSE, //not implemented&#xD;&#xA;                                               peError := ADR(eError) //optional pointer to error&#xD;&#xA;       );&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; :return: new receiver handle or ``CAA.gc_hINVALID`` in case of failure" ObjectGUID="{6a69d079-a320-46bc-8bf1-fa6aa8938d2b}" />
  <Node Name="CreateMessage" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function allocates a new message from the data pool of the driver and makes it available via its&#xD;&#xA; handle ``hMessage``. In addition, the function sets the CAN ID, data length and RTR&#xD;&#xA; flag of the message. Such a message must either be sent with |Write| or released with&#xD;&#xA; |FreeMessage|. It can also be duplicated by use of |CloneMessage|.&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    See |Write|.&#xD;&#xA;  &#xD;&#xA; :return: new message handle or ``CAA.gc_hINVALID`` if no resources left" ObjectGUID="{03ca6e0c-218a-479e-a818-062df9196fdd}" />
  <Node Name="CreateMaskReceiver" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function creates a receiver for a specific identifier area. For receiving a message use the returned receiver handle for |Read| function call.&#xD;&#xA; Mask receivers are very similar to Area Receivers (see also |RegisterIdArea|).&#xD;&#xA; The only difference is that CAN ID filtering is not done by range but by bit mask.&#xD;&#xA; Inputs ``cobIdValue`` and ``cobIdMask`` are interpreted as follows:&#xD;&#xA;&#xD;&#xA; +----------+-+-+-+-+-----------------------------------------------------+&#xD;&#xA; |**Value** |0|1|0|1| **x**: this bit may be either ``TRUE`` or ``FALSE`` |&#xD;&#xA; +----------+-+-+-+-+                                                     +&#xD;&#xA; |**Mask**  |0|0|1|1| **0**: this bit has to be ``FALSE``                 |&#xD;&#xA; +----------+-+-+-+-+                                                     +&#xD;&#xA; |**Result**|X|X|0|1| **1**: this bit hat to be ``TRUE``                  |&#xD;&#xA; +----------+-+-+-+-+-----------------------------------------------------+&#xD;&#xA;&#xD;&#xA; In general: The values of the masks activate the evaluation of the value parameters. &#xD;&#xA; If the mask value is ``FALSE`` the value parameter is ignored.&#xD;&#xA;&#xD;&#xA; There are two kind of receivers:&#xD;&#xA;&#xD;&#xA; * **Always Newest Receivers (xAlwaysNewest := TRUE):** Receiver holds only the last received message.&#xD;&#xA; * **Receiver with Queue (xAlwaysNewest := FALSE):** Receiver holds messages in chronological order.&#xD;&#xA;&#xD;&#xA; Receivers can be also used for Tx loopback. If ``xTransmitMask`` is set to ``FALSE`` or ``xTransmitMask`` and ``xTransmitValue`` are set to ``TRUE`` &#xD;&#xA; CAN messages which are sent via |Write| will be received (applies to all transmit messages on the CAN interface). &#xD;&#xA; Use function |IsTransmitMessage| to distinguish between receive and transmit messages.&#xD;&#xA;&#xD;&#xA; .. note::&#xD;&#xA;&#xD;&#xA;    To avoid losing receive messages an application has to read all messages of a receiver each cycle.&#xD;&#xA;    All messages should be processed and released by |FreeMessage| afterwards.&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;    &#xD;&#xA;       VAR&#xD;&#xA;           hDriver : CAA.HANDLE;&#xD;&#xA;           hReceiver : CAA.HANDLE;&#xD;&#xA;           hMsg : CAA.HANDLE;&#xD;&#xA;           ctMsgLeft : CAA.COUNT;&#xD;&#xA;           eError : CL2.ERROR;&#xD;&#xA;       END_VAR&#xD;&#xA;       &#xD;&#xA;       //Create a MaskReceiver which receives all messages with CAN ID 16#80.&#xD;&#xA;       hReceiver := CL2.CreateMaskReceiver(hDriver := hDriver,&#xD;&#xA;                                           cobIdValue := 16#80, //cobID value&#xD;&#xA;                                           cobIdMask := 16#FFFFFFFF, //cobID mask ==&gt; all bits of value are relevant&#xD;&#xA;                                           xRTRValue := FALSE, //no RTR messages&#xD;&#xA;                                           xRTRMask := TRUE, //activate RTR filter ==&gt; xRTRValue will be checked&#xD;&#xA;                                           x29BitIdValue := FALSE, //no 29 bit CAN messages&#xD;&#xA;                                           x29BitIdMask := TRUE, //activate 29 bit filter ==&gt; x29BitIdValue will be checked&#xD;&#xA;                                           xTransmitValue := FALSE, //only receive messages, no transmit message loopback&#xD;&#xA;                                           xTransmitMask := TRUE, //activate transmit mask filter ==&gt; xTransmitValue will be checked&#xD;&#xA;                                           xAlwaysNewest := FALSE, //FALSE := receiver with queue; TRUE: only newest message&#xD;&#xA;                                           eEvent := CB.EVENT.NO_EVENT, //no receive event&#xD;&#xA;                                           xEnableSyncWindow := FALSE, //not implemented&#xD;&#xA;                                           peError := ADR(eError) //optional pointer to error&#xD;&#xA;       );&#xD;&#xA;       &#xD;&#xA;       REPEAT&#xD;&#xA;           //receive a message from hReceiver&#xD;&#xA;           hMsg := CL2.Read(hReceiverId := hReceiver, pctMsgLeft := ADR(ctMsgLeft), peError := ADR(eError));&#xD;&#xA;           IF hMsg &lt;&gt; CAA.gc_hINVALID THEN&#xD;&#xA;               //TODO: Process message (CL2.GetMessageDataPointer, CL2.GetMessageId, ...)&#xD;&#xA;               CL2.FreeMessage(hMsg); //release message&#xD;&#xA;               hMsg := CAA.gc_hINVALID; //to avoid using an already released message&#xD;&#xA;           END_IF&#xD;&#xA;       UNTIL ctMsgLeft = 0&#xD;&#xA;       END_REPEAT&#xD;&#xA;&#xD;&#xA; Optionally, an event can be registered which is triggered upon reception of a corresponding message. &#xD;&#xA; A callback function can be registerd via ``CB.RegisterCallback`` (CAA Callback library). &#xD;&#xA; Use event class ``CB.EVENT_CLASS.FIELDBUS``, event source ``CB.EVENT_SOURCE.CB_DRIVER`` and any unassigned event number (see ``CB.EVENT``). &#xD;&#xA; Use the same event number for ``eEvent`` input.&#xD;&#xA; Input variable ``dwParam`` of the registered callback function contains the CAN ID of the received message. &#xD;&#xA; See |CreateSingleIdReceiver| for example code.&#xD;&#xA;&#xD;&#xA; .. note::&#xD;&#xA;&#xD;&#xA;    Event mechanism is not supported on all systems. Futhermore it is not possible to register an event for extended identifiers (29bit).&#xD;&#xA;&#xD;&#xA; :return: new receiver handle or ``CAA.gc_hINVALID`` in case of failure" ObjectGUID="{3c1d7ceb-045f-4b73-9033-47f84b0078d6}" />
  <Node Name="CreateIdAreaReceiver" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function creates a receiver to which several identifier areas may be added using the function |RegisterIdArea|.&#xD;&#xA; This receiver type is used if messages within a specific cobID area should be received.&#xD;&#xA; For receiving a message use the returned receiver handle for |Read| function call.&#xD;&#xA; There are two kind of receivers:&#xD;&#xA;&#xD;&#xA; * **Always Newest Receivers (xAlwaysNewest := TRUE):** Receiver holds only the last received message.&#xD;&#xA; * **Receiver with Queue (xAlwaysNewest := FALSE):** Receiver holds messages in chronological order.&#xD;&#xA;&#xD;&#xA; .. note::&#xD;&#xA;&#xD;&#xA;    To avoid losing receive messages an application has to read all messages of a receiver each cycle.&#xD;&#xA;    All messages should be processed and released by |FreeMessage| afterwards.&#xD;&#xA;&#xD;&#xA; .. note::&#xD;&#xA;&#xD;&#xA;    Current implementation of this receiver type does not support 29 bit identifiers.&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;    &#xD;&#xA;       VAR&#xD;&#xA;         hDriver : CAA.HANDLE;&#xD;&#xA;         hReceiver : CAA.HANDLE;&#xD;&#xA;         hMsg : CAA.HANDLE;&#xD;&#xA;         ctMsgLeft : CAA.COUNT;&#xD;&#xA;         eError : CL2.ERROR;&#xD;&#xA;       END_VAR&#xD;&#xA;       &#xD;&#xA;       //Create an IdAreaReceiver&#xD;&#xA;       hReceiver := CL2.CreateIdAreaReceiver(hDriver := hDriver, //driver handle &#xD;&#xA;                                             xAlwaysNewest := FALSE, //FALSE ==&gt; receiver with queue; TRUE ==&gt; only newest message&#xD;&#xA;                                             eEvent := CB.EVENT.NO_EVENT, //no receive event&#xD;&#xA;                                             xEnableSyncWindow := FALSE, //not implemented&#xD;&#xA;                                             peError := ADR(eError) //optional pointer to error&#xD;&#xA;       );&#xD;&#xA;       &#xD;&#xA;       IF hReceiver &lt;&gt; CAA.gc_hINVALID THEN&#xD;&#xA;           //Add an area for CANopen Emergency messages (cobId 16#81-16#9F)&#xD;&#xA;           CL2.RegisterIdArea(hReceiverId := hReceiver, //receiver&#xD;&#xA;                              cobIdStart := 16#81, //start cobID&#xD;&#xA;                              cobIdEnd := 16#9F, //end cobID&#xD;&#xA;                              xRTRValue := FALSE, //no RTR messages&#xD;&#xA;                              xRTRMask := TRUE, //activate RTR filter ==&gt; xRTRValue will be checked&#xD;&#xA;                              x29BitIdValue := FALSE, //no 29 bit CAN messages&#xD;&#xA;                              x29BitIdMask := TRUE, //activate 29 bit filter ==&gt; x29BitIdValue will be checked&#xD;&#xA;                              xTransmitValue := FALSE, //only receive messages, no transmit message loopback&#xD;&#xA;                              xTransmitMask := TRUE //activate transmit mask filter ==&gt; xTransmitValue will be checked&#xD;&#xA;           );&#xD;&#xA;       END_IF&#xD;&#xA;       &#xD;&#xA;       REPEAT&#xD;&#xA;           //receive a message from hReceiver&#xD;&#xA;           hMsg := CL2.Read(hReceiverId := hReceiver, pctMsgLeft := ADR(ctMsgLeft), peError := ADR(eError));&#xD;&#xA;           IF hMsg &lt;&gt; CAA.gc_hINVALID THEN&#xD;&#xA;               //TODO: Process message (CL2.GetMessageDataPointer, CL2.GetMessageId, ...)&#xD;&#xA;               CL2.FreeMessage(hMsg); //release message&#xD;&#xA;               hMsg := CAA.gc_hINVALID; //to avoid using an already released message&#xD;&#xA;           END_IF&#xD;&#xA;       UNTIL ctMsgLeft = 0&#xD;&#xA;       END_REPEAT&#xD;&#xA;&#xD;&#xA; Optionally, an event can be registered which is triggered upon reception of a corresponding message. &#xD;&#xA; A callback function can be registerd via ``CB.RegisterCallback`` (CAA Callback library). &#xD;&#xA; Use event class ``CB.EVENT_CLASS.FIELDBUS``, event source ``CB.EVENT_SOURCE.CB_DRIVER`` and any unassigned event number (see ``CB.EVENT``). &#xD;&#xA; Use the same event number for ``eEvent`` input.&#xD;&#xA; Input variable ``dwParam`` of the registered callback function contains the CAN ID of the received message. &#xD;&#xA; See |CreateSingleIdReceiver| for example code.&#xD;&#xA;&#xD;&#xA; .. note::&#xD;&#xA;&#xD;&#xA;    Event mechanism is not supported on all systems. Futhermore it is not possible to register an event for extended identifiers (29bit).&#xD;&#xA;&#xD;&#xA; :return: new receiver handle or ``CAA.gc_hINVALID`` in case of failure" ObjectGUID="{8a28e4a4-bf07-4f9a-ae9f-0d55e524f0ad}" />
  <Node Name="CloneMessage" TypeGUID="{6f9dac99-8de1-4efc-8465-68ac443b7d08}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94};{3b83b776-fb25-43b8-99f2-3c507c9143fc}" Comment=" This function duplicates an existing message. This duplicated message may be modified and sent via |Write| for example.&#xD;&#xA;&#xD;&#xA; .. admonition:: Example&#xD;&#xA;&#xD;&#xA;    .. code-block:: codesys&#xD;&#xA;&#xD;&#xA;       VAR&#xD;&#xA;         hReceiver : CAA.HANDLE;&#xD;&#xA;         hMsg : CAA.HANDLE;&#xD;&#xA;         hMsgCloned : CAA.HANDLE;&#xD;&#xA;         ctMsgLeft : CAA.COUNT;&#xD;&#xA;         eError : CL2.ERROR;&#xD;&#xA;       END_VAR&#xD;&#xA;    &#xD;&#xA;       //receive a message from hReceiver&#xD;&#xA;       hMsg := CL2.Read(hReceiverId := hReceiver, pctMsgLeft := ADR(ctMsgLeft), peError := ADR(eError));&#xD;&#xA;    &#xD;&#xA;       IF hMsg &lt;&gt; CAA.gc_hINVALID THEN&#xD;&#xA;         //Clone received message&#xD;&#xA;         hMsgCloned := CL2.CloneMessage(hMessage := hMsg, peError := ADR(eError));&#xD;&#xA;    &#xD;&#xA;         //free original message&#xD;&#xA;         CL2.FreeMessage(hMessage := hMsg);&#xD;&#xA;         hMsg := CAA.gc_hINVALID;&#xD;&#xA;    &#xD;&#xA;         //work with hMsgCloned...&#xD;&#xA;       END_IF&#xD;&#xA;&#xD;&#xA; :return: cloned message handle" ObjectGUID="{65d6ee79-7867-42dc-afcc-800fe40d92c9}" />
  <Node Name="DIAGNOSIS_INFO2" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" Comment=" This structure contains all relevant diagnostic information for a CAN FD network. It can be retrieved by |GetFdDiagnosis|." ObjectGUID="{845b69d4-1c28-4ac7-af3b-dcf23d644d50}" />
  <Node Name="DIAGNOSIS_INFO" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" Comment=" This structure contains all relevant diagnostic information for a CAN network. It can be retrieved by |GetDiagnosis|." ObjectGUID="{94f2060f-302c-40fe-a991-6f71ff4d79b6}" />
  <Node Name="ERROR" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" Comment="This data type describes all errors that can occur while running CL2 functions:" ObjectGUID="{78bd25d8-39b1-4b8f-9a2e-961974f9ac60}" />
  <Node Name="BUSSTATE" TypeGUID="{2db5746d-d284-4425-9f7f-2663a34b0ebc}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" Comment="This data type describes the current state of the CAN network." ObjectGUID="{44d5879a-5586-4571-9467-ef379af367e4}" />
  <Node Name="IndicatorConstants" TypeGUID="{ffbfa93a-b94d-45fc-a329-229860183b1d}" EmbeddedTypeGUIDs="{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}" Comment=" This GVL defines the states of the two device LEDs according to CiA 303-3.&#xD;&#xA; These states are returned by |GetCiAState| and set by |SetCiAState|.&#xD;&#xA; The Error LED ``gc_usiERR_...`` (red) is represented by the lower 4 bit of CiA State, the RUN LED ``gc_usiRUN_...`` (green) by the higher 4 bit." ObjectGUID="{924afd6c-9bc3-48cb-b946-fbfb82f92ecc}" />
  <Node Name="Library Manager" TypeGUID="{adb5cb65-8e1d-4a00-b70a-375ea27582f3}" EmbeddedTypeGUIDs="" ObjectGUID="{980b578a-c0a7-4e73-a867-d54ac0b3bf7a}" />
</Library>